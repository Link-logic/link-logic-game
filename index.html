<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Link Logic - Multiplayer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Glossy Button Base Style */
    .glossy-btn {
      position: relative;
      padding: 20px 50px;
      font-size: 24px;
      font-weight: bold;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      text-align: center;
      text-shadow: 0 2px 3px rgba(0,0,0,0.3);
      box-shadow: 
        0 6px 12px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.3),
        inset 0 -2px 0 rgba(0,0,0,0.2);
      transition: all 0.2s;
      overflow: visible;
    }
    
    .glossy-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 100%);
      border-radius: 12px 12px 0 0;
      pointer-events: none;
    }
    
    .glossy-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 
        0 10px 16px rgba(0,0,0,0.5),
        inset 0 1px 0 rgba(255,255,255,0.4),
        inset 0 -2px 0 rgba(0,0,0,0.2);
    }
    
    .glossy-btn:active:not(:disabled) {
      transform: translateY(1px);
      box-shadow: 
        0 3px 6px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.2),
        inset 0 -1px 0 rgba(0,0,0,0.3);
    }
    
    /* Button Color Variants */
    .btn-purple {
      background: linear-gradient(180deg, #7B2CBF 0%, #7B2CBF 30%, #7b1fa2 70%, #6a1b9a 100%);
      color: #fff;
    }
    
    .btn-orange {
      background: linear-gradient(180deg, #ffcc80 0%, #ffb74d 20%, #ff9800 50%, #f57c00 80%, #e65100 100%);
      color: #fff;
    }
    
    .btn-blue {
      background: linear-gradient(180deg, #64b5f6 0%, #42a5f5 20%, #2196f3 50%, #1976d2 80%, #1565c0 100%);
      color: #fff;
    }
    
    .btn-green {
      background: linear-gradient(180deg, #81c784 0%, #66bb6a 30%, #4caf50 70%, #388e3c 100%);
      color: #fff;
    }
    
    .btn-red {
      background: linear-gradient(180deg, #ef5350 0%, #f44336 30%, #e53935 70%, #c62828 100%);
      color: #fff;
    }
    
    .btn-gold {
      background: linear-gradient(180deg, #ffe57f 0%, #ffd54f 20%, #ffb300 50%, #ff8f00 80%, #f57c00 100%);
      color: #000;
    }
    
    .btn-cyan {
      background: linear-gradient(180deg, #4dd0e1 0%, #26c6da 30%, #00bcd4 70%, #0097a7 100%);
      color: #fff;
    }
    
    .btn-disabled {
      background: linear-gradient(180deg, #757575 0%, #616161 50%, #424242 100%);
      color: #bbb;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    /* Input Fields with Colored Borders */
    .input-field {
      padding: 15px 20px;
      font-size: 18px;
      background: #000;
      color: #fff;
      border: 3px solid;
      border-radius: 10px;
      font-family: Arial, sans-serif;
    }
    
    .input-field::placeholder {
      color: #666;
    }
    
    .input-field:focus {
      outline: none;
      box-shadow: 0 0 15px currentColor;
    }
    
    .input-cyan {
      border-color: #00bcd4;
    }
    
    .input-purple {
      border-color: #7B2CBF;
    }
    
    .input-orange {
      border-color: #ff9800;
    }
    
    .input-green {
      border-color: #4caf50;
    }
    
    /* Labels */
    .label-yellow {
      color: #ffeb3b;
      font-weight: bold;
    }
    
    /* Content Boxes */
    .content-box {
      background: #1a1a1a;
      border: 3px solid;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 0 20px rgba(0, 188, 212, 0.3);
    }
    
    .box-cyan {
      border-color: #00bcd4;
    }
    
    .box-purple {
      border-color: #7B2CBF;
    }
    
    .box-orange {
      border-color: #ff9800;
    }
    
    /* Bonus Word Pulse Animation */
    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.03);
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    const firebaseConfig = {
      apiKey: "AIzaSyA26M1QoRi-9iM78jSnn07S4d_8jSy3KIA",
      authDomain: "link-logic-b7aad.firebaseapp.com",
      projectId: "link-logic-b7aad",
      databaseURL: "https://link-logic-b7aad-default-rtdb.firebaseio.com",
      storageBucket: "link-logic-b7aad.firebasestorage.app",
      messagingSenderId: "411607668860",
      appId: "1:411607668860:web:d875c4e4400dbaacda51f9"
    };

    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    const WORD_BANKS = {
      training: [
        'CAT', 'DOG', 'SUN', 'MOON', 'CAR', 'BUS', 'RED', 'BLUE', 'HOT', 'COLD',
        'BIG', 'SMALL', 'UP', 'DOWN', 'YES', 'NO', 'DAY', 'NIGHT', 'HAPPY', 'SAD',
        'RUN', 'WALK', 'EAT', 'DRINK', 'PLAY', 'SLEEP', 'BOY', 'GIRL', 'MOM', 'DAD',
        'HOME', 'SCHOOL', 'PARK', 'STORE', 'BALL', 'TOY', 'BOOK', 'PEN', 'CUP', 'PLATE',
        'BIRD', 'FISH', 'TREE', 'FLOWER', 'RAIN', 'SNOW', 'ICE', 'FIRE', 'HAND', 'FOOT',
        'EYE', 'EAR', 'NOSE', 'HAIR', 'BABY', 'FRIEND', 'MILK', 'JUICE', 'BREAD', 'APPLE',
        'CHAIR', 'TABLE', 'BED', 'DOOR', 'ROOM', 'TV', 'PHONE', 'BAG', 'SHOE', 'HAT',
        'SHIRT', 'PANTS', 'COAT', 'BIKE', 'TRAIN', 'BOAT', 'DUCK', 'COW', 'PIG', 'HORSE',
        'FARM', 'BEACH', 'POOL', 'STAR', 'SKY', 'GRASS', 'ROCK', 'SAND', 'HILL', 'ROAD',
        'BOX', 'KEY', 'GATE', 'BELL', 'GIFT', 'CAKE', 'COOKIE', 'CANDY', 'GAME', 'FUN',
        'SOFT', 'LOUD', 'FAST', 'SLOW', 'NEW', 'OLD', 'GOOD', 'BAD', 'CLEAN', 'DIRTY',
        'WET', 'DRY', 'OPEN', 'CLOSE', 'IN', 'OUT', 'ON', 'OFF', 'LEFT', 'RIGHT',
        'SPIN', 'JUMP', 'SIT', 'STAND', 'PUSH', 'PULL', 'SHAKE', 'NOD', 'CLAP', 'WAVE',
        'SWEET', 'SOUR', 'SALTY', 'SPICY', 'SOFT', 'ROUGH', 'SMOOTH', 'BUMPY', 'THICK', 'THIN',
        'LIGHT', 'HEAVY', 'FULL', 'EMPTY', 'FLAT', 'ROUND', 'LONG', 'SHORT', 'TALL', 'LOW',
        'SOUP', 'RICE', 'MEAT', 'FISH', 'EGG', 'CHEESE', 'CORN', 'BEAN', 'NUT', 'JAM',
        'FORK', 'SPOON', 'KNIFE', 'BOWL', 'GLASS', 'JAR', 'POT', 'PAN', 'OVEN', 'SINK',
        'DESK', 'LAMP', 'CLOCK', 'PILLOW', 'SHEET', 'MAT', 'RUG', 'WALL', 'ROOF', 'FLOOR',
        'SOCK', 'GLOVE', 'BELT', 'TIE', 'DRESS', 'SKIRT', 'JACKET', 'BOOT', 'SLIPPER', 'SCARF',
        'PLANE', 'TRUCK', 'VAN', 'TAXI', 'SHIP', 'ROCKET', 'WHEEL', 'ENGINE', 'MOTOR', 'BRAKE'
      ],
      children: [
        'APPLE', 'TREE', 'HOUSE', 'WATER', 'FIRE', 'PAPER', 'BOOK', 'GREEN', 'LIGHT', 'SWING',
        'SOFT', 'HARD', 'STONE', 'WIND', 'SWEET', 'FAST', 'WARM', 'ANIMAL', 'FRIEND', 'FAMILY',
        'SCHOOL', 'TEACHER', 'STUDENT', 'LEARN', 'PLAY', 'GAME', 'LAUGH', 'SMILE', 'HELP', 'SHARE',
        'GARDEN', 'FLOWER', 'GRASS', 'BIRD', 'FISH', 'RAIN', 'SNOW', 'CLOUD', 'STAR', 'RAINBOW',
        'ORANGE', 'BANANA', 'GRAPE', 'BERRY', 'MELON', 'CARROT', 'PIZZA', 'PASTA', 'SALAD', 'SOUP',
        'TIGER', 'LION', 'BEAR', 'WOLF', 'DEER', 'RABBIT', 'MOUSE', 'FROG', 'BEE', 'BUTTERFLY',
        'OCEAN', 'RIVER', 'LAKE', 'POND', 'STREAM', 'BEACH', 'WAVE', 'SAND', 'SHELL', 'BOAT',
        'FOREST', 'JUNGLE', 'DESERT', 'MOUNTAIN', 'VALLEY', 'CAVE', 'PATH', 'BRIDGE', 'FENCE', 'GATE',
        'SUMMER', 'WINTER', 'SPRING', 'AUTUMN', 'SEASON', 'WEATHER', 'STORM', 'THUNDER', 'LIGHTNING', 'FOG',
        'MONSTER', 'DRAGON', 'FAIRY', 'WIZARD', 'MAGIC', 'CASTLE', 'KNIGHT', 'PRINCESS', 'PRINCE', 'CROWN',
        'MUSIC', 'SONG', 'DANCE', 'DRUM', 'PIANO', 'GUITAR', 'PAINT', 'COLOR', 'DRAW', 'CREATE',
        'SHARK', 'WHALE', 'DOLPHIN', 'SEAL', 'CRAB', 'LOBSTER', 'OCTOPUS', 'STARFISH', 'CORAL', 'JELLYFISH',
        'EAGLE', 'HAWK', 'OWL', 'CROW', 'ROBIN', 'SPARROW', 'PARROT', 'SWAN', 'PENGUIN', 'FLAMINGO',
        'ANT', 'SPIDER', 'BEETLE', 'CRICKET', 'GRASSHOPPER', 'DRAGONFLY', 'LADYBUG', 'FIREFLY', 'MOTH', 'WASP',
        'PUPPY', 'KITTEN', 'LAMB', 'CALF', 'FOAL', 'CHICK', 'DUCKLING', 'FAWN', 'CUB', 'JOEY',
        'TRUNK', 'BRANCH', 'TWIG', 'BARK', 'ROOT', 'LEAF', 'BLOSSOM', 'BUD', 'PETAL', 'STEM',
        'PEBBLE', 'BOULDER', 'CLIFF', 'CANYON', 'ISLAND', 'SHORE', 'BAY', 'GULF', 'HARBOR', 'PIER',
        'SWING', 'SLIDE', 'SEESAW', 'MERRY', 'SANDBOX', 'MONKEY', 'BARS', 'TIRE', 'ROPE', 'TUNNEL',
        'MARBLE', 'DOLL', 'TRUCK', 'PUZZLE', 'BLOCK', 'LEGO', 'CRAYON', 'MARKER', 'CHALK', 'CLAY',
        'STORY', 'TALE', 'FABLE', 'MYTH', 'LEGEND', 'HERO', 'VILLAIN', 'QUEST', 'ADVENTURE', 'JOURNEY',
        'HAPPY', 'EXCITED', 'PROUD', 'BRAVE', 'KIND', 'GENTLE', 'FUNNY', 'SILLY', 'CURIOUS', 'CLEVER'
      ],
      beginners: [
        'APPLE', 'TREE', 'HOUSE', 'WATER', 'FIRE', 'PAPER', 'BOOK', 'GREEN', 'METAL', 'LIGHT',
        'SWING', 'COLD', 'SOFT', 'HARD', 'STONE', 'WIND', 'SWEET', 'FAST', 'BLUE', 'WARM',
        'GLASS', 'WOOD', 'PLASTIC', 'SNOW', 'RAIN', 'SUN', 'MOON', 'STAR', 'CLOUD', 'OCEAN',
        'RIVER', 'MOUNTAIN', 'VALLEY', 'FLOWER', 'GRASS', 'LEAF', 'ROOT', 'SEED', 'FRUIT', 'BREAD',
        'MUSIC', 'SOUND', 'VOICE', 'QUIET', 'LOUD', 'BRIGHT', 'DARK', 'SMOOTH', 'ROUGH', 'CLEAN',
        'SILVER', 'GOLD', 'BRONZE', 'COPPER', 'IRON', 'STEEL', 'DIAMOND', 'RUBY', 'PEARL', 'CRYSTAL',
        'CLOCK', 'TIME', 'HOUR', 'MINUTE', 'SECOND', 'DAY', 'WEEK', 'MONTH', 'YEAR', 'CENTURY',
        'CIRCLE', 'SQUARE', 'TRIANGLE', 'SHAPE', 'LINE', 'CURVE', 'ANGLE', 'CORNER', 'EDGE', 'CENTER',
        'NORTH', 'SOUTH', 'EAST', 'WEST', 'MAP', 'COMPASS', 'DIRECTION', 'LOCATION', 'PLACE', 'SPACE',
        'ENERGY', 'POWER', 'FORCE', 'SPEED', 'MOTION', 'REST', 'BALANCE', 'WEIGHT', 'MASS', 'VOLUME',
        'HEAT', 'COOL', 'WARM', 'FREEZE', 'MELT', 'BOIL', 'STEAM', 'VAPOR', 'LIQUID', 'SOLID',
        'EARTH', 'PLANET', 'ORBIT', 'GRAVITY', 'SPACE', 'GALAXY', 'COMET', 'METEOR', 'ECLIPSE', 'LUNAR',
        'SPRING', 'SUMMER', 'AUTUMN', 'WINTER', 'CLIMATE', 'SEASON', 'TEMPERATURE', 'PRESSURE', 'WEATHER', 'STORM',
        'BRICK', 'CEMENT', 'CONCRETE', 'TILE', 'MARBLE', 'GRANITE', 'SLATE', 'CLAY', 'MORTAR', 'PLASTER',
        'SILK', 'COTTON', 'WOOL', 'LINEN', 'LEATHER', 'FUR', 'VELVET', 'SATIN', 'DENIM', 'CANVAS',
        'MOLECULE', 'ATOM', 'ELEMENT', 'COMPOUND', 'MIXTURE', 'SOLUTION', 'REACTION', 'ACID', 'BASE', 'SALT',
        'VOLTAGE', 'CURRENT', 'CIRCUIT', 'BATTERY', 'CHARGE', 'MAGNET', 'POLE', 'FIELD', 'WAVE', 'SIGNAL',
        'FOSSIL', 'MINERAL', 'ROCK', 'SAND', 'SOIL', 'MUD', 'DUST', 'ASH', 'LAVA', 'MAGMA',
        'TELESCOPE', 'MICROSCOPE', 'LENS', 'MIRROR', 'PRISM', 'SPECTRUM', 'COLOR', 'FREQUENCY', 'AMPLITUDE', 'WAVELENGTH',
        'SHADOW', 'REFLECTION', 'ECHO', 'VIBRATION', 'PITCH', 'TONE', 'RHYTHM', 'BEAT', 'PULSE', 'TEMPO',
        'BRIDGE', 'TOWER', 'DOME', 'ARCH', 'PILLAR', 'BEAM', 'FOUNDATION', 'FRAMEWORK', 'STRUCTURE', 'BUILDING'
      ],
      adults: [
        'ABSTRACT', 'CONCEPT', 'THEORY', 'LOGIC', 'REASON', 'EMOTION', 'THOUGHT', 'MEMORY', 'DREAM', 'REALITY',
        'TRADITION', 'CULTURE', 'SOCIETY', 'COMMUNITY', 'INDIVIDUAL', 'FREEDOM', 'JUSTICE', 'EQUALITY', 'POWER', 'AUTHORITY',
        'ECONOMY', 'MARKET', 'TRADE', 'WEALTH', 'POVERTY', 'CAREER', 'PROFESSION', 'SKILL', 'TALENT', 'EXPERTISE',
        'SCIENCE', 'RESEARCH', 'DISCOVERY', 'INNOVATION', 'TECHNOLOGY', 'PROGRESS', 'EVOLUTION', 'REVOLUTION', 'TRANSFORMATION', 'CHANGE',
        'PHILOSOPHY', 'ETHICS', 'MORALITY', 'VIRTUE', 'INTEGRITY', 'HONESTY', 'TRUST', 'LOYALTY', 'RESPECT', 'DIGNITY',
        'CONFLICT', 'RESOLUTION', 'COMPROMISE', 'NEGOTIATION', 'AGREEMENT', 'COOPERATION', 'COMPETITION', 'STRATEGY', 'TACTICS', 'PLANNING',
        'DEMOCRACY', 'REPUBLIC', 'MONARCHY', 'PARLIAMENT', 'CONGRESS', 'SENATE', 'ELECTION', 'CAMPAIGN', 'POLICY', 'LEGISLATION',
        'CAPITALISM', 'SOCIALISM', 'COMMUNISM', 'LIBERALISM', 'CONSERVATISM', 'IDEOLOGY', 'DOCTRINE', 'PRINCIPLE', 'BELIEF', 'CONVICTION',
        'PSYCHOLOGY', 'SOCIOLOGY', 'ANTHROPOLOGY', 'ARCHAEOLOGY', 'BIOLOGY', 'CHEMISTRY', 'PHYSICS', 'MATHEMATICS', 'GEOMETRY', 'CALCULUS',
        'LITERATURE', 'POETRY', 'PROSE', 'FICTION', 'NARRATIVE', 'CHARACTER', 'PLOT', 'THEME', 'SYMBOL', 'METAPHOR',
        'ARCHITECTURE', 'SCULPTURE', 'PAINTING', 'PHOTOGRAPH', 'CINEMA', 'THEATER', 'PERFORMANCE', 'AUDIENCE', 'CRITIQUE', 'AESTHETIC',
        'RELIGION', 'SPIRITUALITY', 'FAITH', 'WORSHIP', 'RITUAL', 'SACRED', 'DIVINE', 'PROPHET', 'SCRIPTURE', 'DOCTRINE',
        'INVESTMENT', 'STOCK', 'BOND', 'PORTFOLIO', 'DIVIDEND', 'INTEREST', 'INFLATION', 'RECESSION', 'PROSPERITY', 'BUDGET',
        'HIERARCHY', 'BUREAUCRACY', 'INSTITUTION', 'ORGANIZATION', 'CORPORATION', 'ENTERPRISE', 'BUSINESS', 'COMMERCE', 'INDUSTRY', 'SECTOR',
        'COMMUNICATION', 'LANGUAGE', 'RHETORIC', 'DISCOURSE', 'DIALOGUE', 'DEBATE', 'ARGUMENT', 'PERSUASION', 'INFLUENCE', 'MANIPULATION',
        'IDENTITY', 'PERSONALITY', 'CHARACTER', 'TEMPERAMENT', 'DISPOSITION', 'ATTITUDE', 'BEHAVIOR', 'CONDUCT', 'MANNER', 'ETIQUETTE',
        'CONSCIOUSNESS', 'AWARENESS', 'PERCEPTION', 'COGNITION', 'INTELLIGENCE', 'WISDOM', 'KNOWLEDGE', 'UNDERSTANDING', 'COMPREHENSION', 'INSIGHT',
        'AMBITION', 'MOTIVATION', 'DETERMINATION', 'PERSISTENCE', 'RESILIENCE', 'COURAGE', 'CONFIDENCE', 'HUMILITY', 'PATIENCE', 'DISCIPLINE',
        'JEALOUSY', 'ENVY', 'PRIDE', 'GREED', 'ANGER', 'FEAR', 'ANXIETY', 'DEPRESSION', 'EUPHORIA', 'MELANCHOLY',
        'PREJUDICE', 'DISCRIMINATION', 'STEREOTYPE', 'BIAS', 'TOLERANCE', 'DIVERSITY', 'INCLUSION', 'EQUITY', 'PRIVILEGE', 'OPPRESSION',
        'HERITAGE', 'ANCESTRY', 'LINEAGE', 'GENEALOGY', 'LEGACY', 'INHERITANCE', 'SUCCESSION', 'DYNASTY', 'EMPIRE', 'KINGDOM',
        'TREATY', 'ALLIANCE', 'COALITION', 'FEDERATION', 'UNION', 'PARTNERSHIP', 'COLLABORATION', 'SOLIDARITY', 'UNITY', 'DIVISION',
        'MANUSCRIPT', 'JOURNAL', 'ESSAY', 'ARTICLE', 'THESIS', 'DISSERTATION', 'PUBLICATION', 'EDITION', 'VOLUME', 'CHAPTER',
        'SYMPHONY', 'CONCERTO', 'SONATA', 'OPERA', 'BALLET', 'ORCHESTRA', 'CONDUCTOR', 'COMPOSER', 'HARMONY', 'MELODY',
        'GALLERY', 'MUSEUM', 'EXHIBITION', 'COLLECTION', 'ARTIFACT', 'MASTERPIECE', 'CANVAS', 'PORTRAIT', 'LANDSCAPE', 'ABSTRACT'
      ]
    };

    const generateRoomCode = () => {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    };

    // Better shuffle algorithm (Fisher-Yates)
    const shuffleArray = (array) => {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    };

    const generateWordsAvoidingRecent = (difficulty, numWords, recentWords = [], bonusCount = 0) => {
      const wordBank = WORD_BANKS[difficulty];
      
      // Separate into recent and fresh words
      const freshWords = wordBank.filter(word => !recentWords.includes(word));
      const recentWordsInBank = wordBank.filter(word => recentWords.includes(word));
      
      // Shuffle fresh words first (prioritize new words)
      const shuffledFresh = shuffleArray(freshWords);
      const shuffledRecent = shuffleArray(recentWordsInBank);
      
      // Combine: try to use fresh words first, fall back to recent if needed
      const combined = [...shuffledFresh, ...shuffledRecent];
      
      const selectedWords = combined.slice(0, numWords);
      
      // Mark random words as bonus words
      const bonusIndices = [];
      if (bonusCount > 0) {
        const indices = Array.from({length: selectedWords.length}, (_, i) => i);
        const shuffledIndices = shuffleArray(indices);
        bonusIndices.push(...shuffledIndices.slice(0, Math.min(bonusCount, selectedWords.length)));
      }
      
      // Return words with bonus marking
      return selectedWords.map((word, idx) => ({
        text: word,
        isBonus: bonusIndices.includes(idx)
      }));
    };
    
    const generateWords = (difficulty, numWords, bonusCount = 0) => {
      const wordBank = WORD_BANKS[difficulty];
      
      // Shuffle entire bank
      const shuffled = shuffleArray(wordBank);
      
      // Take from shuffled bank
      const selectedWords = shuffled.slice(0, numWords);
      
      // Mark random words as bonus words
      const bonusIndices = [];
      if (bonusCount > 0) {
        const indices = Array.from({length: selectedWords.length}, (_, i) => i);
        const shuffledIndices = shuffleArray(indices);
        bonusIndices.push(...shuffledIndices.slice(0, Math.min(bonusCount, selectedWords.length)));
      }
      
      // Return words with bonus marking
      return selectedWords.map((word, idx) => ({
        text: word,
        isBonus: bonusIndices.includes(idx)
      }));
    };

    const CopyIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
      </svg>
    );

    const CheckIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="20 6 9 17 4 12"/>
      </svg>
    );

    const UsersIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/>
        <circle cx="9" cy="7" r="4"/>
        <path d="M22 21v-2a4 4 0 0 0-3-3.87"/>
        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
      </svg>
    );

    const MultiplayerLinkLogic = () => {
      // Always start at splash screen
      const [screen, setScreen] = useState('splash');
      const [playerName, setPlayerName] = useState(() => {
        const registration = localStorage.getItem('linkLogicRegistration');
        return registration ? JSON.parse(registration).playerName : '';

      });
      
      // Registration fields
      const [regName, setRegName] = useState('');
      const [regCell, setRegCell] = useState('');
      const [regEmail, setRegEmail] = useState('');
      const [regPlayerName, setRegPlayerName] = useState('');
      const [playerNameAvailable, setPlayerNameAvailable] = useState(null);
      const [checkingPlayerName, setCheckingPlayerName] = useState(false);
      
      const [roomCode, setRoomCode] = useState('');
      const [joinRoomInput, setJoinRoomInput] = useState('');
      const [playerId, setPlayerId] = useState(null);
      const [isHost, setIsHost] = useState(false);
      
      const [gameData, setGameData] = useState(null);
      const [players, setPlayers] = useState([]);
      
      // Practice mode state
      const [isPracticeMode, setIsPracticeMode] = useState(false);
      const [practiceConfig, setPracticeConfig] = useState({
        numBots: 2,
        botDifficulty: 'medium',
        gameConfig: null
      });
      const [practiceGameState, setPracticeGameState] = useState(null);
      const [isPaused, setIsPaused] = useState(false);
      
      const [selectedWords, setSelectedWords] = useState([]);
      const [linkWord, setLinkWord] = useState('');
      const [copied, setCopied] = useState(false);
      const [tick, setTick] = useState(0);
      const [spellCheckTimer, setSpellCheckTimer] = useState(null);
      const [soundMuted, setSoundMuted] = useState(() => {
        const saved = localStorage.getItem('linkLogicSoundMuted');
        return saved === 'true';
      });
      
      // Invite system
      const [showInviteScreen, setShowInviteScreen] = useState(false);
      const [inviteLinkCopied, setInviteLinkCopied] = useState(false);
      const [inviteMessage, setInviteMessage] = useState("You're invited to play Link Logic!\n\nA fun multiplayer word game - no download needed.");
      
      // 9 Preset Difficulty Levels
      const PRESETS = {
        1: { 
          name: 'Preset 1', 
          color: '#00ffff', // Electric Cyan (Easy)
          difficulty: 'children', 
          numWords: 22, 
          roundTimer: 120, 
          bonusWords: 5,
          numRounds: 5,
          description: 'Easiest - Perfect for beginners'
        },
        2: { 
          name: 'Preset 2', 
          color: '#0099ff', // Vivid Blue (Easy)
          difficulty: 'children', 
          numWords: 20, 
          roundTimer: 110, 
          bonusWords: 4,
          numRounds: 5,
          description: 'Easy - Learning the game'
        },
        3: { 
          name: 'Preset 3', 
          color: '#0055ff', // Deep Blue (Easy)
          difficulty: 'children', 
          numWords: 18, 
          roundTimer: 100, 
          bonusWords: 3,
          numRounds: 5,
          description: 'Easy - Building skills'
        },
        4: { 
          name: 'Preset 4', 
          color: '#ffee00', // Bright Yellow (Medium)
          difficulty: 'adults', 
          numWords: 20, 
          roundTimer: 110, 
          bonusWords: 4,
          numRounds: 5,
          description: 'Medium - Getting challenging'
        },
        5: { 
          name: 'Preset 5', 
          color: '#ff9900', // Vivid Orange (Medium)
          difficulty: 'adults', 
          numWords: 18, 
          roundTimer: 100, 
          bonusWords: 3,
          numRounds: 5,
          description: 'Medium - Real competition'
        },
        6: { 
          name: 'Preset 6', 
          color: '#ff6600', // Bright Orange (Medium)
          difficulty: 'adults', 
          numWords: 16, 
          roundTimer: 90, 
          bonusWords: 2,
          numRounds: 5,
          description: 'Medium - Advanced play'
        },
        7: { 
          name: 'Preset 7', 
          color: '#ff4444', // Bright Red (Difficult)
          difficulty: 'beginners', 
          numWords: 18, 
          roundTimer: 100, 
          bonusWords: 3,
          numRounds: 5,
          description: 'Difficult - Expert level'
        },
        8: { 
          name: 'Preset 8', 
          color: '#ff0000', // Pure Red (Difficult)
          difficulty: 'beginners', 
          numWords: 16, 
          roundTimer: 90, 
          bonusWords: 2,
          numRounds: 5,
          description: 'Difficult - Master challenge'
        },
        9: { 
          name: 'Preset 9', 
          color: '#bb0000', // Blood Red (Difficult)
          difficulty: 'beginners', 
          numWords: 14, 
          roundTimer: 80, 
          bonusWords: 1,
          numRounds: 5,
          description: 'Hardest - Ultimate test'
        }
      };
      
      const [selectedPreset, setSelectedPreset] = useState(4); // Default to Preset 4 (medium)
      const [isEditingPreset, setIsEditingPreset] = useState(false);
      const [customPresetSettings, setCustomPresetSettings] = useState(null);
      
      // Sound effects using Web Audio API
      const playSound = (type) => {
        if (soundMuted) return;
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        switch(type) {
          case 'submit': // Submit link - quick pop
            oscillator.frequency.value = 800;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
            break;
            
          case 'tick': // Last 10 seconds countdown
            oscillator.frequency.value = 440;
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
            break;
            
          case 'timeup': // Round over ding
            oscillator.frequency.value = 880;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
            break;
            
          case 'accept': // Challenge accepted
            oscillator.frequency.value = 600;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.15);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            oscillator.stop(audioContext.currentTime + 0.15);
            break;
            
          case 'reject': // Challenge rejected
            oscillator.frequency.value = 300;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            oscillator.stop(audioContext.currentTime + 0.2);
            break;
            
          case 'star': // Star vote sparkle
            oscillator.frequency.value = 1200;
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
            break;
            
          case 'winner': // Winner fanfare (5 seconds max)
            // Play a simple ascending chord
            const frequencies = [523, 659, 784, 1047]; // C major chord
            frequencies.forEach((freq, i) => {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              osc.connect(gain);
              gain.connect(audioContext.destination);
              osc.frequency.value = freq;
              gain.gain.setValueAtTime(0.15, audioContext.currentTime + i * 0.1);
              gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.1 + 0.8);
              osc.start(audioContext.currentTime + i * 0.1);
              osc.stop(audioContext.currentTime + i * 0.1 + 0.8);
            });
            return; // Skip default oscillator cleanup
        }
      };
      
      const toggleSound = () => {
        const newValue = !soundMuted;
        setSoundMuted(newValue);
        localStorage.setItem('linkLogicSoundMuted', newValue.toString());
        if (!newValue) {
          playSound('submit'); // Test sound when unmuting
        }
      };
      
      // ========================================
      // BOT AI LOGIC FOR PRACTICE MODE
      // ========================================
      
      const getBotLinkWord = (words, difficulty) => {
        // Generate plausible link words based on common associations
        const linkWords = [
          'TREE', 'WOOD', 'GREEN', 'WATER', 'HOUSE', 'PAPER', 'LIGHT', 'DARK',
          'FIRE', 'COLD', 'HOT', 'SOFT', 'HARD', 'FAST', 'SLOW', 'BIG', 'SMALL',
          'METAL', 'GLASS', 'STONE', 'WIND', 'SUN', 'MOON', 'STAR', 'CLOUD',
          'OCEAN', 'MOUNTAIN', 'FOREST', 'DESERT', 'CITY', 'COUNTRY', 'BEACH',
          'SNOW', 'RAIN', 'STORM', 'BLUE', 'RED', 'YELLOW', 'BLACK', 'WHITE'
        ];
        
        // Pick a random link word
        return linkWords[Math.floor(Math.random() * linkWords.length)];
      };
      
      const botSubmitLink = (bot, randomWords, config) => {
        if (!isPracticeMode || !practiceGameState) return;
        
        // Determine how many words to link based on difficulty
        let numWordsToLink;
        if (bot.difficulty === 'easy') {
          numWordsToLink = 2;
        } else if (bot.difficulty === 'medium') {
          numWordsToLink = Math.random() < 0.7 ? 2 : 3;
        } else { // hard
          const rand = Math.random();
          numWordsToLink = rand < 0.4 ? 2 : rand < 0.8 ? 3 : 4;
        }
        
        // Randomly select words
        const shuffled = [...randomWords].sort(() => Math.random() - 0.5);
        const selectedWords = shuffled.slice(0, Math.min(numWordsToLink, randomWords.length));
        
        // Generate link word
        const linkWord = getBotLinkWord(selectedWords, bot.difficulty);
        
        // Calculate points
        const points = config.points[Math.min(selectedWords.length, 5)];
        
        return {
          words: selectedWords,
          link: linkWord,
          points: points,
          accepted: true
        };
      };
      
      const getBotSubmissionDelay = (difficulty) => {
        // Return delay in milliseconds
        if (difficulty === 'easy') {
          return 15000 + Math.random() * 15000; // 15-30 seconds
        } else if (difficulty === 'medium') {
          return 10000 + Math.random() * 10000; // 10-20 seconds
        } else { // hard
          return 5000 + Math.random() * 10000; // 5-15 seconds
        }
      };
      
      const botShouldChallenge = (difficulty, submission) => {
        // Bots rarely challenge in practice mode to keep it simple
        if (difficulty === 'easy') {
          return Math.random() < 0.05; // 5% chance
        } else if (difficulty === 'medium') {
          return Math.random() < 0.1; // 10% chance
        } else { // hard
          return Math.random() < 0.15; // 15% chance
        }
      };
      
      const botVoteOnChallenge = (difficulty) => {
        // Return 'accept' or 'reject'
        if (difficulty === 'easy') {
          return Math.random() < 0.8 ? 'accept' : 'reject'; // 80% accept
        } else if (difficulty === 'medium') {
          return Math.random() < 0.6 ? 'accept' : 'reject'; // 60% accept
        } else { // hard
          return Math.random() < 0.4 ? 'accept' : 'reject'; // 40% accept
        }
      };
      
      const botGiveStarVote = (difficulty, allSubmissions) => {
        // Return player ID to vote for, or null
        if (Math.random() < 0.7) { // 70% chance to vote
          // Pick a random submission from other players
          const otherSubmissions = allSubmissions.filter(s => !s.isBot || Math.random() < 0.5);
          if (otherSubmissions.length > 0) {
            const randomSub = otherSubmissions[Math.floor(Math.random() * otherSubmissions.length)];
            return randomSub.playerId;
          }
        }
        return null;
      };
      
      // Practice mode state management
      const updatePracticeGameState = (updates) => {
        if (!isPracticeMode) return;
        
        setGameData(prev => ({
          ...prev,
          ...updates
        }));
        
        setPracticeGameState(prev => ({
          ...prev,
          ...updates
        }));
      };
      
      const advancePracticeRound = () => {
        if (!isPracticeMode || !practiceGameState) return;
        
        // Calculate scores
        const updatedPlayers = players.map(p => {
          const roundScore = (p.submissions || []).reduce((sum, sub) => sum + (sub.accepted ? sub.points : 0), 0);
          return {
            ...p,
            totalScore: (p.totalScore || 0) + roundScore,
            submissions: [],
            ready: false
          };
        });
        
        setPlayers(updatedPlayers);
        
        if (practiceGameState.currentRound < practiceGameState.config.numRounds) {
          // Next round
          const newWords = generateWordsAvoidingRecent(
            practiceGameState.config.difficulty,
            practiceGameState.config.numWords,
            practiceGameState.recentlyUsedWords || [],
            practiceGameState.config.bonusWords || 0
          );
          
          updatePracticeGameState({
            gameState: 'countdown',
            currentRound: practiceGameState.currentRound + 1,
            randomWords: newWords,
            countdownStep: 'tap',
            challenges: [],
            starVotes: {},
            recentlyUsedWords: [...newWords, ...(practiceGameState.recentlyUsedWords || [])].slice(0, 30)
          });
        } else {
          // Game end
          updatePracticeGameState({
            gameState: 'gameEnd'
          });
        }
      };

      // Force timer display to update every second
      useEffect(() => {
        const tickInterval = setInterval(() => {
          setTick(t => t + 1);
        }, 1000);
        return () => clearInterval(tickInterval);
      }, []);
      
      // Auto-fill room code from URL parameter
      useEffect(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const joinCode = urlParams.get('join') || urlParams.get('room');
        if (joinCode) {
          setJoinRoomInput(joinCode.toUpperCase());
        }
      }, []);
      
      // Clear selected words when round ends or new round starts
      useEffect(() => {
        if (gameData?.gameState === 'roundOver' || gameData?.gameState === 'countdown') {
          setSelectedWords([]);
          setLinkWord('');
          if (spellCheckTimer) {
            clearTimeout(spellCheckTimer);
            setSpellCheckTimer(null);
          }
        }
      }, [gameData?.gameState]);

      useEffect(() => {
        if (!roomCode) return;
        
        const roomRef = database.ref(`rooms/${roomCode}`);
        roomRef.on('value', (snapshot) => {
          const data = snapshot.val();
          if (data) {
            setGameData(data);
            setPlayers(Object.values(data.players || {}));
          }
        });
        
        return () => roomRef.off();
      }, [roomCode]);
      
      // Play winner sound when game ends
      useEffect(() => {
        if (gameData?.gameState === 'gameEnd') {
          playSound('winner');
        }
      }, [gameData?.gameState]);

      const createRoom = async () => {
        if (!playerName.trim()) return;
        
        const newRoomCode = generateRoomCode();
        const newPlayerId = Date.now().toString();
        const preset = PRESETS[selectedPreset];
        
        // Use custom settings if they exist, otherwise use preset defaults
        const settings = customPresetSettings || preset;
        
        const roomData = {
          hostId: newPlayerId,
          config: {
            numWords: settings.numWords,
            roundTimer: settings.roundTimer,
            numRounds: settings.numRounds,
            bonusWords: settings.bonusWords,
            points: { 2: 2, 3: 4, 4: 8, 5: 16 },
            difficulty: preset.difficulty,
            presetLevel: selectedPreset
          },
          gameState: 'lobby',
          currentRound: 0,
          challenges: [],
          currentChallengeIndex: 0,
          players: {
            [newPlayerId]: {
              id: newPlayerId,
              name: playerName.trim(),
              isHost: true,
              ready: false,
              submissions: [],
              totalScore: 0
            }
          }
        };
        
        await database.ref(`rooms/${newRoomCode}`).set(roomData);
        
        setRoomCode(newRoomCode);
        setPlayerId(newPlayerId);
        setIsHost(true);
        setScreen('lobby');
      };

      const joinRoom = async () => {
        if (!playerName.trim() || !joinRoomInput.trim()) return;
        
        const roomRef = database.ref(`rooms/${joinRoomInput.toUpperCase()}`);
        const snapshot = await roomRef.once('value');
        
        if (!snapshot.exists()) {
          alert('Room not found!');
          return;
        }
        
        const roomData = snapshot.val();
        const existingPlayers = Object.values(roomData.players || {});
        const existingPlayer = existingPlayers.find(p => p.name.toLowerCase() === playerName.trim().toLowerCase());
        
        // Allow rejoining if you were already in the game
        if (existingPlayer) {
          setRoomCode(joinRoomInput.toUpperCase());
          setPlayerId(existingPlayer.id);
          setIsHost(existingPlayer.isHost);
          setScreen('lobby');
          return;
        }
        
        // Block new players from joining if game already started
        if (roomData.gameState !== 'lobby') {
          alert('Game already in progress! Wait for it to finish or ask the host to restart.');
          return;
        }
        
        const newPlayerId = Date.now().toString();
        
        await database.ref(`rooms/${joinRoomInput.toUpperCase()}/players/${newPlayerId}`).update({
          id: newPlayerId,
          name: playerName.trim(),
          isHost: false,
          ready: false,
          submissions: [],
          totalScore: 0
        });
        
        setRoomCode(joinRoomInput.toUpperCase());
        setPlayerId(newPlayerId);
        setIsHost(false);
        setScreen('lobby');
      };

      const updateConfig = async (newConfig) => {
        if (!isHost) return;
        await database.ref(`rooms/${roomCode}/config`).update(newConfig);
      };

      const startGame = async () => {
        if (!isHost) return;
        
        // Get recently used words from previous rounds (if any)
        const recentWords = gameData.recentlyUsedWords || [];
        const wordObjects = generateWordsAvoidingRecent(
          gameData.config.difficulty, 
          gameData.config.numWords,
          recentWords,
          gameData.config.bonusWords || 0
        );
        
        // Extract just the text for tracking recent words
        const wordTexts = wordObjects.map(w => w.text);
        
        // Update recently used words (keep last 30 words to avoid)
        const updatedRecentWords = [...wordTexts, ...recentWords].slice(0, 30);
        
        await database.ref(`rooms/${roomCode}`).update({
          gameState: 'countdown',
          currentRound: 1,
          randomWords: wordObjects,
          recentlyUsedWords: updatedRecentWords,
          countdownStep: 'tap',
          challenges: [],
          currentChallengeIndex: 0,
          starVotes: {}
        });
      };

      const handleTapToStart = async () => {
        if (isPracticeMode) {
          // Practice mode - update local state
          updatePracticeGameState({ countdownStep: 'ready' });
          
          setTimeout(() => {
            updatePracticeGameState({ countdownStep: 'set' });
            
            setTimeout(() => {
              updatePracticeGameState({ countdownStep: 'go' });
              
              setTimeout(() => {
                updatePracticeGameState({
                  gameState: 'playing',
                  timer: gameData.config.roundTimer,
                  timerStartTime: Date.now()
                });
              }, 1000);
            }, 1000);
          }, 1000);
        } else {
          // Multiplayer mode - update Firebase
          await database.ref(`rooms/${roomCode}`).update({
            countdownStep: 'ready'
          });
          
          setTimeout(async () => {
            await database.ref(`rooms/${roomCode}`).update({
              countdownStep: 'set'
            });
            
            setTimeout(async () => {
              await database.ref(`rooms/${roomCode}`).update({
                countdownStep: 'go'
              });
              
              setTimeout(async () => {
                await database.ref(`rooms/${roomCode}`).update({
                  gameState: 'playing',
                  timer: gameData.config.roundTimer,
                  timerStartTime: Date.now()
                });
              }, 1000);
            }, 1000);
          }, 1000);
        }
      };

      useEffect(() => {
        if (!gameData || gameData.gameState !== 'playing' || !gameData.timerStartTime) return;
        if (isPracticeMode && isPaused) return; // Don't run timer when paused in practice
        
        let lastSecond = null;
        
        const checkTimer = async () => {
          const elapsed = Math.floor((Date.now() - gameData.timerStartTime) / 1000);
          const remaining = gameData.config.roundTimer - elapsed;
          
          // Play tick sound in last 10 seconds (once per second)
          if (remaining <= 10 && remaining > 0 && remaining !== lastSecond) {
            playSound('tick');
            lastSecond = remaining;
          }
          
          if (remaining < 1) {
            if (isPracticeMode || isHost) {
              playSound('timeup');
              
              if (isPracticeMode) {
                // Practice mode - update local state
                updatePracticeGameState({
                  gameState: 'roundOver',
                  timer: 0
                });
              } else {
                // Multiplayer mode - update Firebase
                await database.ref(`rooms/${roomCode}`).update({
                  gameState: 'roundOver',
                  timer: 0
                });
              }
            }
          }
        };
        
        const interval = setInterval(checkTimer, 100);
        
        return () => clearInterval(interval);
      }, [gameData?.gameState, gameData?.timerStartTime, isHost, roomCode, isPracticeMode, isPaused]);
      
      // Bot AI gameplay - Submit links during practice mode
      useEffect(() => {
        if (!isPracticeMode || !gameData || gameData.gameState !== 'playing') return;
        if (isPaused) return;
        
        const botTimers = [];
        
        // Schedule submissions for each bot
        players.filter(p => p.isBot).forEach(bot => {
          const scheduleNextSubmission = () => {
            const delay = getBotSubmissionDelay(bot.difficulty);
            const elapsed = Date.now() - (gameData.timerStartTime || Date.now());
            const remaining = (gameData.config.roundTimer * 1000) - elapsed;
            
            if (delay < remaining - 2000) { // Leave 2 seconds buffer
              const timer = setTimeout(() => {
                // Submit a link for this bot
                const submission = botSubmitLink(bot, gameData.randomWords, gameData.config);
                
                // Update bot's submissions in local state
                setPlayers(prevPlayers => {
                  return prevPlayers.map(p => {
                    if (p.id === bot.id) {
                      return {
                        ...p,
                        submissions: [...(p.submissions || []), submission]
                      };
                    }
                    return p;
                  });
                });
                
                // Schedule another submission if time allows
                scheduleNextSubmission();
              }, delay);
              
              botTimers.push(timer);
            }
          };
          
          scheduleNextSubmission();
        });
        
        return () => {
          botTimers.forEach(timer => clearTimeout(timer));
        };
      }, [isPracticeMode, gameData?.gameState, gameData?.timerStartTime, isPaused]);

      const toggleWord = (word) => {
        if (selectedWords.includes(word)) {
          setSelectedWords(selectedWords.filter(w => w !== word));
        } else {
          setSelectedWords([...selectedWords, word]);
        }
      };

      const submitLink = async () => {
        if (selectedWords.length < 2 || !linkWord.trim()) return;
        
        playSound('submit'); // Play submit sound
        
        const numWords = selectedWords.length;
        let points = gameData.config.points[Math.min(numWords, 5)];
        
        // Check if any selected word is a bonus word
        const randomWords = gameData.randomWords || [];
        const hasBonusWord = selectedWords.some(selectedWord => {
          const wordObj = randomWords.find(w => 
            (typeof w === 'string' ? w : w.text) === selectedWord
          );
          return wordObj && typeof wordObj === 'object' && wordObj.isBonus;
        });
        
        // Award bonus point if any bonus word was used
        if (hasBonusWord) {
          points += 1;
        }
        
        const submission = {
          words: [...selectedWords],
          link: linkWord.trim().toUpperCase(), // Convert to uppercase on submit
          points: points,
          accepted: true,
          hadBonus: hasBonusWord
        };
        
        if (isPracticeMode) {
          // Practice mode - update local state
          setPlayers(prevPlayers => {
            return prevPlayers.map(p => {
              if (p.id === playerId) {
                return {
                  ...p,
                  submissions: [...(p.submissions || []), submission]
                };
              }
              return p;
            });
          });
        } else {
          // Multiplayer mode - update Firebase
          const currentSubmissions = gameData.players[playerId]?.submissions || [];
          
          await database.ref(`rooms/${roomCode}/players/${playerId}`).update({
            submissions: [...currentSubmissions, submission]
          });
        }
        
        setSelectedWords([]);
        setLinkWord('');
      };

      const handleReady = async () => {
        if (isPracticeMode) {
          // Practice mode - simpler flow
          // Mark human player as ready
          setPlayers(prevPlayers => {
            return prevPlayers.map(p => ({
              ...p,
              ready: true // Auto-ready all players including bots
            }));
          });
          
          // Wait a moment then advance
          setTimeout(() => {
            advancePracticeRound();
          }, 1000);
          
          return;
        }
        
        // Multiplayer mode - original Firebase logic
        try {
          // Set this player as ready
          await database.ref(`rooms/${roomCode}/players/${playerId}`).update({
            ready: true
          });
          
          // Check if all players are ready and advance automatically
          setTimeout(async () => {
            try {
              const snapshot = await database.ref(`rooms/${roomCode}`).once('value');
              const data = snapshot.val();
              
              if (!data) {
                console.error('No room data found');
                return;
              }
              
              // Check if advancement is already in progress
              if (data.advancementInProgress) {
                console.log('Advancement already in progress, skipping');
                return;
              }
              
              const allPlayers = Object.values(data.players || {});
              const allReady = allPlayers.every(p => p.ready);
              
              console.log('All ready:', allReady, 'Players:', allPlayers.length);
              
              // Check if there are any unresolved challenges
              const challenges = data.challenges || [];
              if (challenges.length > 0) {
                console.log('Challenges exist, not advancing');
                return;
              }
              
              // Set flag to prevent duplicate advancement
              if (allReady) {
                await database.ref(`rooms/${roomCode}/advancementInProgress`).set(true);
                
                if (data.currentRound < data.config.numRounds) {
                  console.log('Advancing to next round');
                  
                  // Get recently used words and generate new ones avoiding repetition
                  const recentWords = data.recentlyUsedWords || [];
                  const wordObjects = generateWordsAvoidingRecent(
                    data.config.difficulty, 
                    data.config.numWords,
                    recentWords,
                    data.config.bonusWords || 0
                  );
                  
                  // Extract just the text for tracking recent words
                  const wordTexts = wordObjects.map(w => w.text);
                  
                  // Update recently used words (keep last 30 to avoid)
                  const updatedRecentWords = [...wordTexts, ...recentWords].slice(0, 30);
                  
                  const updates = {};
                  allPlayers.forEach(p => {
                    updates[`players/${p.id}/ready`] = false;
                    updates[`players/${p.id}/submissions`] = [];
                    const roundScore = (p.submissions || []).reduce((sum, sub) => sum + (sub.accepted ? sub.points : 0), 0);
                    updates[`players/${p.id}/totalScore`] = (p.totalScore || 0) + roundScore;
                  });
                  
                  await database.ref(`rooms/${roomCode}`).update({
                    ...updates,
                    gameState: 'countdown',
                    currentRound: data.currentRound + 1,
                    randomWords: wordObjects,
                    recentlyUsedWords: updatedRecentWords,
                    countdownStep: 'tap',
                    challenges: [],
                    currentChallengeIndex: 0,
                    starVotes: {},
                    advancementInProgress: false
                  });
                } else {
                  console.log('Going to game end');
                  const updates = {};
                  allPlayers.forEach(p => {
                    const roundScore = (p.submissions || []).reduce((sum, sub) => sum + (sub.accepted ? sub.points : 0), 0);
                    updates[`players/${p.id}/totalScore`] = (p.totalScore || 0) + roundScore;
                  });
                  
                  await database.ref(`rooms/${roomCode}`).update({
                    ...updates,
                    gameState: 'gameEnd',
                    advancementInProgress: false
                  });
                }
              }
            } catch (error) {
              console.error('Error in advancement:', error);
              await database.ref(`rooms/${roomCode}/advancementInProgress`).set(false);
            }
          }, 1000);
        } catch (error) {
          console.error('Error setting ready status:', error);
        }
      };

      const copyRoomCode = () => {
        navigator.clipboard.writeText(roomCode);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      };
      
      const copyInviteLink = () => {
        // Use the actual deployed URL
        const baseUrl = window.location.hostname === 'link-logic.github.io' 
          ? 'https://link-logic.github.io/Gameplan'
          : window.location.origin || 'https://link-logic.github.io/Gameplan';
        
        const inviteLink = `${baseUrl}?room=${roomCode}`;
        
        // Auto-generated lines (always included)
        const autoLines = `Join my Link Logic game!\nRoom Code: ${roomCode}\nGame Room: ${inviteLink}`;
        
        // Combine custom message with auto-generated lines
        const fullMessage = inviteMessage.trim() 
          ? `${inviteMessage.trim()}\n\n${autoLines}`
          : autoLines;
        
        navigator.clipboard.writeText(fullMessage);
        setInviteLinkCopied(true);
        setTimeout(() => setInviteLinkCopied(false), 2000);
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const getTimeRemaining = () => {
        if (!gameData || !gameData.timerStartTime) return gameData?.config?.roundTimer || 120;
        const elapsed = Math.floor((Date.now() - gameData.timerStartTime) / 1000);
        return Math.max(0, gameData.config.roundTimer - elapsed);
      };

      // Challenge system functions
      const addChallenge = async (targetPlayerId, subIdx) => {
        const challenges = gameData.challenges || [];
        const newChallenge = { 
          playerId: targetPlayerId, 
          subIdx: subIdx,
          defenderId: targetPlayerId,
          challengerId: playerId,
          defense: null,
          votes: {},
          result: null
        };
        
        console.log('Creating new challenge:', newChallenge);
        
        if (!challenges.find(c => c.playerId === targetPlayerId && c.subIdx === subIdx)) {
          if (isPracticeMode) {
            // Practice mode - update local state
            updatePracticeGameState({
              challenges: [...challenges, newChallenge]
            });
          } else {
            // Multiplayer mode - update Firebase
            await database.ref(`rooms/${roomCode}/challenges`).set([...challenges, newChallenge]);
            console.log('Challenge added to Firebase');
          }
        }
      };

      const removeChallenge = async (targetPlayerId, subIdx) => {
        const challenges = gameData.challenges || [];
        const filtered = challenges.filter(c => !(c.playerId === targetPlayerId && c.subIdx === subIdx));
        
        if (isPracticeMode) {
          // Practice mode - update local state
          const currentIndex = gameData.currentChallengeIndex || 0;
          let newIndex = currentIndex;
          
          if (currentIndex > filtered.length - 1 && filtered.length > 0) {
            newIndex = filtered.length - 1;
          } else if (filtered.length === 0) {
            newIndex = 0;
          }
          
          updatePracticeGameState({
            challenges: filtered,
            currentChallengeIndex: newIndex
          });
        } else {
          // Multiplayer mode - update Firebase
          await database.ref(`rooms/${roomCode}/challenges`).set(filtered);
          
          // Reset index if needed
          if (gameData.currentChallengeIndex > filtered.length - 1 && filtered.length > 0) {
            await database.ref(`rooms/${roomCode}/currentChallengeIndex`).set(filtered.length - 1);
          } else if (filtered.length === 0) {
            await database.ref(`rooms/${roomCode}/currentChallengeIndex`).set(0);
          }
        }
      };

      const submitDefense = async (defenseText) => {
        const challenges = gameData.challenges || [];
        const currentIndex = gameData.currentChallengeIndex || 0;
        
        if (challenges[currentIndex]) {
          challenges[currentIndex].defense = defenseText;
          
          if (isPracticeMode) {
            // Practice mode - update local state
            updatePracticeGameState({ challenges: challenges });
          } else {
            // Multiplayer mode - update Firebase
            await database.ref(`rooms/${roomCode}/challenges`).set(challenges);
          }
        }
      };

      const submitVote = async (voteType) => {
        const challenges = gameData.challenges || [];
        const currentIndex = gameData.currentChallengeIndex || 0;
        
        console.log('submitVote called:', { voteType, currentIndex, challengesLength: challenges.length });
        
        if (challenges[currentIndex]) {
          // Ensure votes object exists
          if (!challenges[currentIndex].votes) {
            challenges[currentIndex].votes = {};
          }
          
          challenges[currentIndex].votes[playerId] = voteType;
          
          if (isPracticeMode) {
            // Practice mode - update local state
            updatePracticeGameState({ challenges: challenges });
          } else {
            // Multiplayer mode - update Firebase
            await database.ref(`rooms/${roomCode}/challenges`).set(challenges);
          }
          
          console.log('Vote submitted, challenges updated:', challenges[currentIndex]);
          
          // Check if all eligible voters have voted
          const challenge = challenges[currentIndex];
          const eligibleVoters = players.filter(p => p.id !== challenge.defenderId);
          const voteCount = Object.keys(challenge.votes).length;
          
          console.log('Challenge voting:', {
            totalPlayers: players.length,
            eligibleVoters: eligibleVoters.length,
            voteCount: voteCount,
            challengerId: challenge.challengerId,
            defenderId: challenge.defenderId,
            votes: challenge.votes
          });
          
          if (voteCount > eligibleVoters.length - 1) {
            // Count votes
            const acceptCount = Object.values(challenge.votes).filter(v => v === 'accept').length;
            const rejectCount = Object.values(challenge.votes).filter(v => v === 'reject').length;
            
            console.log('Vote counts:', { acceptCount, rejectCount, eligibleVoters: eligibleVoters.length });
            
            // FIX: In 2-player games (1 eligible voter), auto-accept (benefit of doubt)
            let result;
            if (eligibleVoters.length === 1) {
              result = 'accepted';
              console.log('2-player game: Auto-accepting challenge');
            } else {
              // Ties go to defender: accept unless reject count is GREATER
              result = rejectCount > acceptCount ? 'rejected' : 'accepted';
              console.log('Normal voting - Ties favor defender:', result, `(${acceptCount} accept vs ${rejectCount} reject)`);
            }
            
            challenges[currentIndex].result = result;
            
            // Play sound based on result
            playSound(result === 'accepted' ? 'accept' : 'reject');
            
            console.log('Result set:', result);
            
            // Update submission accepted status and advance
            if (isPracticeMode) {
              // Practice mode
              if (result === 'rejected') {
                setPlayers(prevPlayers => {
                  return prevPlayers.map(p => {
                    if (p.id === challenge.playerId) {
                      const updatedSubmissions = [...p.submissions];
                      if (updatedSubmissions[challenge.subIdx]) {
                        updatedSubmissions[challenge.subIdx].accepted = false;
                      }
                      return { ...p, submissions: updatedSubmissions };
                    }
                    return p;
                  });
                });
              }
              
              updatePracticeGameState({ challenges: challenges });
              
              // Move to next challenge or finish
              setTimeout(() => {
                if (currentIndex < challenges.length - 1) {
                  updatePracticeGameState({ currentChallengeIndex: currentIndex + 1 });
                } else {
                  // All challenges resolved
                  updatePracticeGameState({ 
                    challenges: [],
                    currentChallengeIndex: 0
                  });
                }
              }, 2000);
            } else {
              // Multiplayer mode - Firebase
              await database.ref(`rooms/${roomCode}/challenges`).set(challenges);
              
              if (result === 'rejected') {
                await database.ref(`rooms/${roomCode}/players/${challenge.playerId}/submissions/${challenge.subIdx}/accepted`).set(false);
              }
              
              // Move to next challenge or finish
              setTimeout(async () => {
                if (currentIndex < challenges.length - 1) {
                  await database.ref(`rooms/${roomCode}/currentChallengeIndex`).set(currentIndex + 1);
                } else {
                  // All challenges resolved
                  await database.ref(`rooms/${roomCode}/challenges`).set([]);
                  await database.ref(`rooms/${roomCode}/currentChallengeIndex`).set(0);
                }
              }, 2000);
            }
          }
        }
      };

      const getCurrentChallenge = () => {
        const challenges = gameData?.challenges || [];
        const index = gameData?.currentChallengeIndex || 0;
        return challenges[index] || null;
      };

      const isSubmissionChallenged = (targetPlayerId, subIdx) => {
        const challenges = gameData?.challenges || [];
        return challenges.some(c => c.playerId === targetPlayerId && c.subIdx === subIdx);
      };

      const isCurrentChallenge = (targetPlayerId, subIdx) => {
        const current = getCurrentChallenge();
        return current && current.playerId === targetPlayerId && current.subIdx === subIdx;
      };

      // Splash Screen with Logo
      if (screen === 'splash') {
        return (
          <div className="min-h-screen flex items-center justify-center p-5" style={{background: '#000000'}}>
            <div className="w-full max-w-md" style={{
              background: '#000000',
              border: '4px solid #7B2CBF',
              borderRadius: '10px',
              padding: '40px 30px',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center'
            }}>
              <h1 className="text-5xl font-bold text-white text-center mb-8">Welcome</h1>
              
              {/* Logo in purple frame - expand to fill interior */}
              <div style={{
                background: '#000000',
                border: '6px solid #7B2CBF',
                borderRadius: '10px',
                padding: '15px',
                marginBottom: '40px',
                width: '100%',
                maxWidth: '350px',
                minHeight: '250px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }}>
                <img 
                  src="./logo-full.png"
                  alt="Link Logic"
                  style={{
                    width: '100%',
                    height: 'auto',
                    display: 'block'
                  }}
                  onError={(e) => {
                    // Show fallback text if image fails to load
                    e.target.style.display = 'none';
                    e.target.parentElement.innerHTML = '<div style="color: #7B2CBF; text-align: center; font-size: 24px; font-weight: bold; padding: 20px;">LINK<br/>LOGIC<br/><span style="font-size: 14px; color: white; margin-top: 10px; display: block;">Logo image missing<br/>Add logo-full.png to same folder</span></div>';
                  }}
                />
              </div>
              
              {/* Larger subtitle */}
              <p className="text-white text-2xl text-center mb-8 leading-relaxed">
                A Multiplayer<br/>Word Connection Game
              </p>
              
              {/* Deeper purple Enter button */}
              <button
                onClick={() => {
                  const registered = localStorage.getItem('linkLogicRegistration');
                  setScreen(registered ? 'welcome' : 'register');
                }}
                style={{
                  background: '#7B2CBF',
                  color: '#FFFFFF',
                  padding: '18px 80px',
                  borderRadius: '30px',
                  fontSize: '28px',
                  fontWeight: 'bold',
                  border: 'none',
                  cursor: 'pointer',
                  transition: 'transform 0.2s',
                  boxShadow: '0 4px 12px rgba(123, 44, 191, 0.4)'
                }}
                onMouseOver={(e) => e.target.style.transform = 'scale(1.05)'}
                onMouseOut={(e) => e.target.style.transform = 'scale(1)'}
              >
                Enter
              </button>
            </div>
          </div>
        );
      }
      
      // Registration Screen (for new players only)
      if (screen === 'register') {
        // Check player name availability in Firebase
        const checkPlayerNameAvailability = async (name) => {
          if (!name || name.length < 3) {
            setPlayerNameAvailable(null);
            return;
          }
          
          setCheckingPlayerName(true);
          
          try {
            // Search all rooms for this player name
            const roomsRef = database.ref('rooms');
            const snapshot = await roomsRef.once('value');
            const rooms = snapshot.val() || {};
            
            // Check if player name exists in any room
            let nameExists = false;
            Object.values(rooms).forEach(room => {
              if (room.players) {
                Object.values(room.players).forEach(player => {
                  if (player.name && player.name.toLowerCase() === name.toLowerCase()) {
                    nameExists = true;
                  }
                });
              }
            });
            
            setPlayerNameAvailable(!nameExists);
          } catch (error) {
            console.error('Error checking player name:', error);
            setPlayerNameAvailable(null);
          }
          
          setCheckingPlayerName(false);
        };
        
        // Save registration
        const handleRegistration = () => {
          if (!regName.trim() || !regCell.trim() || !regPlayerName.trim()) {
            alert('Please fill in all required fields (Name, Cell, Game Player Name)');
            return;
          }
          
          if (playerNameAvailable === false) {
            alert('This Game Player Name is already taken. Please choose another.');
            return;
          }
          
          // Save to localStorage
          const registration = {
            name: regName.trim(),
            cell: regCell.trim(),
            email: regEmail.trim(),
            playerName: regPlayerName.trim(),
            registeredAt: Date.now()
          };
          
          localStorage.setItem('linkLogicRegistration', JSON.stringify(registration));
          setPlayerName(regPlayerName.trim());
          setScreen('welcome');
        };
        
        return (
          <div className="min-h-screen p-5 flex items-center justify-center" style={{background: '#000000'}}>
            <style>{`
              input[type="text"]::placeholder,
              input[type="email"]::placeholder,
              input[type="tel"]::placeholder {
                color: #666666 !important;
                opacity: 0.8;
              }
            `}</style>
            <div className="max-w-md w-full rounded-xl shadow-2xl p-8 border-4 relative" style={{backgroundColor: '#000000', borderColor: '#7B2CBF'}}>
              
              {/* Small logo in top left */}
              <img 
                src="./logo-small.png" 
                alt="Link Logic" 
                style={{
                  position: 'absolute',
                  top: '20px',
                  left: '20px',
                  width: '60px',
                  height: 'auto',
                  borderRadius: '8px'
                }}
              />
              
              {/* Header */}
              <h1 className="text-4xl font-bold text-white text-center mb-6 pt-4">Register</h1>
              
              <div style={{backgroundColor: '#7B2CBF', borderRadius: '15px', padding: '25px 20px'}}>
                
                {/* Your Name */}
                <div className="mb-4">
                  <label className="block font-bold mb-2" style={{color: '#F88E00', fontSize: '18px'}}>Your Name*</label>
                  <input
                    type="text"
                    value={regName}
                    onChange={(e) => setRegName(e.target.value)}
                    placeholder="Enter your full name"
                    className="w-full p-3 rounded-lg outline-none"
                    style={{backgroundColor: '#FFFFFF', border: '3px solid #00B0F0', color: '#000000'}}
                    maxLength={50}
                  />
                </div>
                
                {/* Your Cell */}
                <div className="mb-4">
                  <label className="block font-bold mb-2" style={{color: '#F88E00', fontSize: '18px'}}>Your Cell*</label>
                  <input
                    type="tel"
                    value={regCell}
                    onChange={(e) => setRegCell(e.target.value)}
                    placeholder="Enter your phone number"
                    className="w-full p-3 rounded-lg outline-none"
                    style={{backgroundColor: '#FFFFFF', border: '3px solid #00B0F0', color: '#000000'}}
                    maxLength={20}
                  />
                </div>
                
                {/* Your Email */}
                <div className="mb-4">
                  <label className="block font-bold mb-2" style={{color: '#F88E00', fontSize: '18px'}}>Your Email</label>
                  <input
                    type="email"
                    value={regEmail}
                    onChange={(e) => setRegEmail(e.target.value)}
                    placeholder="Enter your email"
                    className="w-full p-3 rounded-lg outline-none"
                    style={{backgroundColor: '#FFFFFF', border: '3px solid #00B0F0', color: '#000000'}}
                    maxLength={100}
                  />
                </div>
                
                <p className="text-sm mb-4" style={{color: '#F88E00'}}>* Required</p>
                
                {/* Create Your Player Name - larger font, cyan color */}
                <h2 className="font-bold mb-3 text-center" style={{color: '#00B0F0', fontSize: '24px'}}>
                  Create Your Player Name
                </h2>
                
                {/* Player Name Input - light gray background, dark gray text */}
                <div className="mb-4">
                  <input
                    type="text"
                    value={regPlayerName}
                    onChange={(e) => {
                      setRegPlayerName(e.target.value);
                      clearTimeout(window.playerNameCheckTimeout);
                      window.playerNameCheckTimeout = setTimeout(() => {
                        checkPlayerNameAvailability(e.target.value);
                      }, 500);
                    }}
                    placeholder="Type in a Player Name"
                    className="w-full p-3 rounded-lg outline-none"
                    style={{
                      backgroundColor: '#ECECEC', 
                      border: '3px solid #F88E00',
                      color: '#000000',
                      fontSize: '16px'
                    }}
                    maxLength={20}
                  />
                  {checkingPlayerName && (
                    <p className="text-sm text-white opacity-75 mt-1">Checking availability...</p>
                  )}
                  {!checkingPlayerName && playerNameAvailable === true && regPlayerName.length >= 3 && (
                    <p className="text-sm mt-1" style={{color: '#4ade80'}}> This name is available!</p>
                  )}
                  {!checkingPlayerName && playerNameAvailable === false && (
                    <p className="text-sm mt-2 text-center font-bold" style={{
                      backgroundColor: '#ECECEC',
                      color: '#C0C0C0',
                      padding: '10px',
                      borderRadius: '8px'
                    }}>Not Available - Try Again</p>
                  )}
                </div>
                
                {/* Check Availability Button */}
                <button
                  onClick={() => checkPlayerNameAvailability(regPlayerName)}
                  disabled={!regPlayerName.trim() || regPlayerName.length < 3}
                  className="w-full py-3 rounded-lg font-bold text-lg mb-3 transition-all disabled:opacity-50"
                  style={{background: '#00B0F0', color: '#FFFFFF'}}
                >
                  Check for Availability
                </button>
                
                {/* Bottom Buttons - shorter (py-2.5) */}
                <div className="flex gap-2">
                  <button
                    onClick={() => setScreen('instructions')}
                    className="flex-1 py-2.5 rounded-lg font-bold text-lg transition-all"
                    style={{backgroundColor: '#F88E00', color: '#FFFFFF'}}
                  >
                    Instructions
                  </button>
                  
                  <button
                    onClick={handleRegistration}
                    disabled={!regName.trim() || !regCell.trim() || !regPlayerName.trim() || playerNameAvailable === false}
                    className="flex-1 py-2.5 rounded-lg font-bold text-lg transition-all disabled:opacity-50"
                    style={{backgroundColor: '#F88E00', color: '#FFFFFF'}}
                  >
                    Ready to Play?
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'welcome') {
        return (
          <div className="min-h-screen p-5 flex items-center justify-center" style={{background: '#000000'}}>
            <div className="max-w-md w-full rounded-xl shadow-2xl p-8 border-4 relative" style={{backgroundColor: '#000000', borderColor: '#7B2CBF'}}>
              
              {/* Small logo in top left */}
              <img 
                src="./logo-small.png" 
                alt="Link Logic" 
                style={{
                  position: 'absolute',
                  top: '20px',
                  left: '20px',
                  width: '60px',
                  height: 'auto',
                  borderRadius: '8px'
                }}
              />
              
              {/* Header */}
              <h1 className="text-4xl font-bold text-white text-center mb-6 pt-4">Player Modes</h1>
              
              <div style={{backgroundColor: '#7B2CBF', borderRadius: '15px', padding: '25px 20px'}}>
                
                {/* Red header text "Host - Join - Find" */}
                <h2 className="font-bold text-center mb-5" style={{color: '#F31418', fontSize: '24px'}}>
                  Host - Join - Find
                </h2>
                
                {/* Player Name and Rating - Cyan labels, side by side */}
                <div className="grid grid-cols-2 gap-3 mb-5">
                  <div>
                    <label className="block font-bold mb-2" style={{color: '#00B0F0', fontSize: '16px'}}>Player Name:</label>
                    <input
                      type="text"
                      value={playerName}
                      onChange={(e) => setPlayerName(e.target.value)}
                      placeholder="Self Propagates"
                      className="w-full p-2 rounded-lg outline-none"
                      style={{backgroundColor: '#FFFFFF', border: '3px solid #00B0F0', color: '#000000', fontSize: '14px'}}
                      maxLength={20}
                    />
                  </div>
                  <div>
                    <label className="block font-bold mb-2" style={{color: '#00B0F0', fontSize: '16px'}}>Rating</label>
                    <input
                      type="text"
                      value="Self Propagates"
                      readOnly
                      className="w-full p-2 rounded-lg outline-none"
                      style={{backgroundColor: '#FFFFFF', border: '3px solid #00B0F0', color: '#000000', fontSize: '14px'}}
                    />
                  </div>
                </div>
                
                {/* Host a Game - Red button */}
                <button
                  onClick={createRoom}
                  disabled={!playerName.trim()}
                  className="w-full py-4 rounded-lg font-bold text-xl mb-2 transition disabled:opacity-50"
                  style={{background: '#F31418', color: '#FFFFFF', fontSize: '22px'}}
                >
                  Host a Game
                </button>
                {/* Next Step - LEFT aligned */}
                <p className="mb-4" style={{color: '#FFFFFF', fontSize: '14px', textAlign: 'left'}}>Next Step: Set Presets</p>
                
                {/* Game Number Input - for Join a Game */}
                <div className="mb-3">
                  <label className="block font-bold mb-2" style={{color: '#00B0F0', fontSize: '16px'}}>Game Number:</label>
                  <input
                    type="text"
                    value={joinRoomInput}
                    onChange={(e) => setJoinRoomInput(e.target.value.toUpperCase())}
                    placeholder="Enter 6-digit code"
                    className="w-full p-2 rounded-lg outline-none uppercase"
                    style={{backgroundColor: '#FFFFFF', border: '3px solid #00B0F0', color: '#000000', fontSize: '14px'}}
                    maxLength={6}
                  />
                </div>
                
                {/* Join a Game - Orange button */}
                <button
                  onClick={joinRoom}
                  disabled={!playerName.trim() || !joinRoomInput.trim()}
                  className="w-full py-4 rounded-lg font-bold text-xl mb-2 transition disabled:opacity-50"
                  style={{background: '#F88E00', color: '#FFFFFF', fontSize: '22px'}}
                >
                  Join a Game
                </button>
                {/* Next Step - LEFT aligned */}
                <p className="mb-4" style={{color: '#FFFFFF', fontSize: '14px', textAlign: 'left'}}>Next Step: Waiting Room</p>
                
                {/* Find a Game - Cyan button (disabled) */}
                <button
                  disabled
                  className="w-full py-4 rounded-lg font-bold text-xl mb-2 transition opacity-50 cursor-not-allowed"
                  style={{background: '#00B0F0', color: '#FFFFFF', fontSize: '22px'}}
                >
                  Find a Game
                </button>
                {/* Next Step - LEFT aligned */}
                <p className="mb-6" style={{color: '#FFFFFF', fontSize: '14px', textAlign: 'left'}}>Next Step: Search Online</p>
                
                {/* Instructions button - Orange, smaller, centered */}
                <div className="flex justify-center">
                  <button
                    onClick={() => setScreen('instructions')}
                    className="py-2.5 px-8 rounded-lg font-bold transition"
                    style={{backgroundColor: '#F88E00', color: '#FFFFFF', fontSize: '18px'}}
                  >
                    Instructions
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // Game Instructions Screen
      if (screen === 'instructions') {
        return (
          <div className="min-h-screen p-6 flex items-center justify-center" style={{background: '#000000'}}>
            <div className="max-w-2xl w-full rounded-xl shadow-2xl p-8 border-4" style={{backgroundColor: '#000000', borderColor: '#7B2CBF'}}>
              <div className="mb-6" style={{backgroundColor: '#7B2CBF', margin: '-2rem -2rem 1.5rem -2rem', padding: '1.5rem', borderRadius: '1rem 1rem 0 0'}}>
                <h1 className="text-5xl font-bold text-center text-white">How to Play Link Logic</h1>
              </div>
              
              <div className="space-y-4 text-white">
                <div>
                  <h2 className="text-5xl font-bold mb-2" style={{color: '#7B2CBF'}}> Objective</h2>
                  <p>Find creative connections between random words using a "link" word.</p>
                </div>
                
                <div>
                  <h2 className="text-5xl font-bold mb-2" style={{color: '#7B2CBF'}}> How to Play</h2>
                  <ol className="list-decimal list-inside space-y-2 ml-4">
                    <li>Each round, you'll see 12 random words</li>
                    <li>Select 2 or more words that you can connect</li>
                    <li>Type a "link" word that connects them</li>
                    <li>Submit before time runs out</li>
                  </ol>
                </div>
                
                <div>
                  <h2 className="text-5xl font-bold mb-2" style={{color: '#7B2CBF'}}> Example</h2>
                  <p className="p-3 rounded-lg" style={{backgroundColor: '#1a1a1a', border: '2px solid #7B2CBF'}}>
                    <strong>Words:</strong> SNOW, FIRE<br/>
                    <strong>Link:</strong> WHITE<br/>
                    <strong>Connection:</strong> Snow is white, fire can burn white-hot
                  </p>
                </div>
                
                <div>
                  <h2 className="text-5xl font-bold mb-2" style={{color: '#7B2CBF'}}> Scoring</h2>
                  <ul className="list-disc list-inside space-y-1 ml-4">
                    <li>2 words = 2 points</li>
                    <li>3 words = 4 points</li>
                    <li>4 words = 8 points</li>
                    <li>5+ words = 16 points</li>
                  </ul>
                </div>
                
                <div>
                  <h2 className="text-5xl font-bold mb-2" style={{color: '#7B2CBF'}}> Bonus Points</h2>
                  <p>Vote for the funniest or most creative link each round to give bonus points!</p>
                </div>
                
                <div>
                  <h2 className="text-5xl font-bold mb-2" style={{color: '#7B2CBF'}}> Challenges</h2>
                  <p>Think someone's link doesn't work? Challenge it! Other players vote to accept or reject.</p>
                </div>
                
                <div>
                  <h2 className="text-5xl font-bold mb-2" style={{color: '#7B2CBF'}}> Reconnecting</h2>
                  <p>If you get disconnected during a game, check your invitation text for the <strong>Game Room</strong> link to rejoin quickly!</p>
                </div>
              </div>
              
              <button
                onClick={() => setScreen('welcome')}
                className="w-full py-4 rounded-lg font-bold text-5xl mt-6 transition shadow-lg hover:shadow-xl"
                style={{background: 'linear-gradient(180deg, #7B2CBF 0%, #7B2CBF 50%, #7b1fa2 100%)', color: '#ffffff'}}
              >
                BACK TO MENU
              </button>
            </div>
          </div>
        );
      }

      // Practice Mode Setup Screen

      if (screen === 'lobby' && gameData?.gameState === 'lobby') {
        return (
          <div className="min-h-screen p-5 flex items-center justify-center" style={{background: '#000000'}}>
            <div className="w-full rounded-3xl shadow-2xl p-8" style={{
              backgroundColor: '#000000',
              borderColor: '#8B5CF6',
              border: '8px solid',
              maxWidth: '480px',
              minHeight: '90vh'
            }}>
              
              {/* Small logo in top left */}
              <img 
                src="./logo-small.png" 
                alt="Link Logic" 
                style={{
                  position: 'absolute',
                  top: '20px',
                  left: '20px',
                  width: '70px',
                  height: 'auto',
                  borderRadius: '8px'
                }}
              />
              
              {/* Page Title */}
              <h1 className="text-4xl font-bold text-white text-center mb-6">Host Room</h1>
              
              {/* Main Content Box - Purple */}
              <div style={{backgroundColor: '#8B5CF6', borderRadius: '20px', padding: '30px 25px'}}>
                
                {/* Room Code Section */}
                <div className="mb-6">
                  <div className="flex items-center gap-3 mb-2">
                    <div style={{
                      background: '#00BCD4',
                      color: '#FFFFFF',
                      padding: '10px 15px',
                      borderRadius: '8px',
                      fontSize: '14px',
                      fontWeight: 'bold',
                      whiteSpace: 'nowrap'
                    }}>
                      Room Number:
                    </div>
                    <div style={{
                      background: '#FFFFFF',
                      padding: '10px 15px',
                      borderRadius: '8px',
                      flex: '1',
                      textAlign: 'center',
                      color: '#FF9800',
                      fontSize: '20px',
                      fontWeight: 'bold',
                      fontFamily: 'monospace'
                    }}>
                      {roomCode}
                    </div>
                    <button
                      onClick={copyRoomCode}
                      style={{
                        background: '#00BCD4',
                        color: '#FFFFFF',
                        width: '50px',
                        height: '50px',
                        borderRadius: '50%',
                        border: 'none',
                        fontSize: '24px',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center'
                      }}
                    >
                      {copied ? '' : ''}
                    </button>
                  </div>
                  <p style={{color: '#FFFFFF', fontSize: '12px', textAlign: 'center'}}>Share this code with friends to join!</p>
                </div>

                {/* Players Section */}
                <div style={{
                  background: '#FFFFFF',
                  border: '3px solid #000000',
                  borderRadius: '15px',
                  padding: '20px',
                  marginBottom: '20px'
                }}>
                  <h3 style={{fontSize: '20px', fontWeight: 'bold', textAlign: 'center', marginBottom: '15px', color: '#000000'}}>
                    Players ({players.length})
                  </h3>
                  <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px'}}>
                    {players.map(p => (
                      <div key={p.id} style={{
                        background: '#FFFFFF',
                        border: '3px solid #8B5CF6',
                        borderRadius: '10px',
                        padding: '12px',
                        textAlign: 'center',
                        color: p.id === playerId ? '#000000' : '#666666',
                        fontSize: '14px',
                        fontWeight: p.id === playerId ? 'bold' : 'normal'
                      }}>
                        {p.name}
                        {p.isHost && <span style={{display: 'block', fontSize: '10px', color: '#FF9800'}}>HOST</span>}
                      </div>
                    ))}
                  </div>
                </div>

                {/* Preset Selection - Only show for host */}
                {isHost && (
                  <>
                    <div style={{color: '#FFFFFF', fontSize: '24px', fontWeight: 'bold', marginBottom: '15px', textAlign: 'center'}}>
                      Select Difficulty Level
                    </div>
                    
                    <div style={{display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '12px', marginBottom: '20px'}}>
                      {[1,2,3,4,5,6,7,8,9].map(presetNum => {
                        const preset = PRESETS[presetNum];
                        const isSelected = selectedPreset === presetNum;
                        return (
                          <button
                            key={presetNum}
                            onClick={() => {
                              setSelectedPreset(presetNum);
                              const settingsToUse = (presetNum === selectedPreset && customPresetSettings) 
                                ? customPresetSettings 
                                : preset;
                              updateConfig({
                                ...gameData.config,
                                numWords: settingsToUse.numWords,
                                roundTimer: settingsToUse.roundTimer,
                                numRounds: settingsToUse.numRounds,
                                bonusWords: settingsToUse.bonusWords,
                                difficulty: preset.difficulty,
                                presetLevel: presetNum
                              });
                            }}
                            style={{
                              backgroundColor: preset.color,
                              padding: '20px',
                              borderRadius: '12px',
                              border: isSelected ? '4px solid #FFFFFF' : 'none',
                              fontSize: '16px',
                              fontWeight: 'bold',
                              color: '#FFFFFF',
                              cursor: 'pointer',
                              textAlign: 'center',
                              transform: isSelected ? 'scale(1.05)' : 'scale(1)',
                              transition: 'all 0.2s'
                            }}
                          >
                            <div style={{fontSize: '24px'}}>Preset</div>
                            <div style={{fontSize: '32px'}}>{presetNum}</div>
                          </button>
                        );
                      })}
                    </div>
                    
                    {/* Preset Info Box */}
                    <div style={{
                      background: '#FFFFFF',
                      border: '3px solid #000000',
                      borderRadius: '15px',
                      padding: '20px',
                      marginBottom: '20px',
                      color: '#000000'
                    }}>
                      <h3 style={{fontSize: '18px', marginBottom: '8px', textAlign: 'center', fontWeight: 'bold'}}>
                        Level {selectedPreset} Preset Settings:
                      </h3>
                      <div style={{fontSize: '14px', marginBottom: '15px', textAlign: 'center'}}>
                        Level: {PRESETS[selectedPreset].description}
                      </div>
                      
                      {!isEditingPreset ? (
                        <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', fontSize: '15px'}}>
                          <div><strong>Words:</strong> {customPresetSettings?.numWords || PRESETS[selectedPreset].numWords}</div>
                          <div><strong>Timer:</strong> {customPresetSettings?.roundTimer || PRESETS[selectedPreset].roundTimer}s</div>
                          <div><strong>Rounds:</strong> {customPresetSettings?.numRounds || PRESETS[selectedPreset].numRounds}</div>
                          <div><strong>Bonus Words:</strong> {customPresetSettings?.bonusWords || PRESETS[selectedPreset].bonusWords}</div>
                        </div>
                      ) : (
                        <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px'}}>
                          <div>
                            <label style={{display: 'block', fontWeight: 'bold', marginBottom: '5px', fontSize: '14px'}}>Words:</label>
                            <input
                              type="number"
                              min="8"
                              max="30"
                              value={customPresetSettings?.numWords || PRESETS[selectedPreset].numWords}
                              onChange={(e) => setCustomPresetSettings({
                                numWords: parseInt(e.target.value) || PRESETS[selectedPreset].numWords,
                                roundTimer: customPresetSettings?.roundTimer || PRESETS[selectedPreset].roundTimer,
                                numRounds: customPresetSettings?.numRounds || PRESETS[selectedPreset].numRounds,
                                bonusWords: customPresetSettings?.bonusWords || PRESETS[selectedPreset].bonusWords
                              })}
                              style={{width: '100%', padding: '8px', border: '2px solid #ccc', borderRadius: '6px'}}
                            />
                          </div>
                          <div>
                            <label style={{display: 'block', fontWeight: 'bold', marginBottom: '5px', fontSize: '14px'}}>Timer:</label>
                            <input
                              type="number"
                              min="30"
                              max="300"
                              value={customPresetSettings?.roundTimer || PRESETS[selectedPreset].roundTimer}
                              onChange={(e) => setCustomPresetSettings({
                                numWords: customPresetSettings?.numWords || PRESETS[selectedPreset].numWords,
                                roundTimer: parseInt(e.target.value) || PRESETS[selectedPreset].roundTimer,
                                numRounds: customPresetSettings?.numRounds || PRESETS[selectedPreset].numRounds,
                                bonusWords: customPresetSettings?.bonusWords || PRESETS[selectedPreset].bonusWords
                              })}
                              style={{width: '100%', padding: '8px', border: '2px solid #ccc', borderRadius: '6px'}}
                            />
                          </div>
                          <div>
                            <label style={{display: 'block', fontWeight: 'bold', marginBottom: '5px', fontSize: '14px'}}>Rounds:</label>
                            <input
                              type="number"
                              min="1"
                              max="10"
                              value={customPresetSettings?.numRounds || PRESETS[selectedPreset].numRounds}
                              onChange={(e) => setCustomPresetSettings({
                                numWords: customPresetSettings?.numWords || PRESETS[selectedPreset].numWords,
                                roundTimer: customPresetSettings?.roundTimer || PRESETS[selectedPreset].roundTimer,
                                numRounds: parseInt(e.target.value) || PRESETS[selectedPreset].numRounds,
                                bonusWords: customPresetSettings?.bonusWords || PRESETS[selectedPreset].bonusWords
                              })}
                              style={{width: '100%', padding: '8px', border: '2px solid #ccc', borderRadius: '6px'}}
                            />
                          </div>
                          <div>
                            <label style={{display: 'block', fontWeight: 'bold', marginBottom: '5px', fontSize: '14px'}}>Bonus Words:</label>
                            <input
                              type="number"
                              min="0"
                              max="10"
                              value={customPresetSettings?.bonusWords || PRESETS[selectedPreset].bonusWords}
                              onChange={(e) => setCustomPresetSettings({
                                numWords: customPresetSettings?.numWords || PRESETS[selectedPreset].numWords,
                                roundTimer: customPresetSettings?.roundTimer || PRESETS[selectedPreset].roundTimer,
                                numRounds: customPresetSettings?.numRounds || PRESETS[selectedPreset].numRounds,
                                bonusWords: parseInt(e.target.value) || PRESETS[selectedPreset].bonusWords
                              })}
                              style={{width: '100%', padding: '8px', border: '2px solid #ccc', borderRadius: '6px'}}
                            />
                          </div>
                        </div>
                      )}
                    </div>
                    
                    {/* Edit/Save/Reset Buttons */}
                    <div style={{display: 'flex', justifyContent: 'space-between', gap: '10px', marginBottom: '20px'}}>
                      <button
                        onClick={() => {
                          setIsEditingPreset(true);
                          if (!customPresetSettings) {
                            setCustomPresetSettings({
                              numWords: PRESETS[selectedPreset].numWords,
                              roundTimer: PRESETS[selectedPreset].roundTimer,
                              numRounds: PRESETS[selectedPreset].numRounds,
                              bonusWords: PRESETS[selectedPreset].bonusWords
                            });
                          }
                        }}
                        disabled={isEditingPreset}
                        style={{
                          flex: 1,
                          padding: '12px',
                          borderRadius: '10px',
                          border: 'none',
                          fontSize: '16px',
                          fontWeight: 'bold',
                          cursor: isEditingPreset ? 'not-allowed' : 'pointer',
                          background: '#00BCD4',
                          color: '#FFFFFF',
                          opacity: isEditingPreset ? 0.5 : 1
                        }}
                      >
                        Edit
                      </button>
                      <button
                        onClick={() => {
                          setIsEditingPreset(false);
                          if (customPresetSettings) {
                            updateConfig({
                              ...gameData.config,
                              numWords: customPresetSettings.numWords,
                              roundTimer: customPresetSettings.roundTimer,
                              numRounds: customPresetSettings.numRounds,
                              bonusWords: customPresetSettings.bonusWords,
                              presetLevel: selectedPreset
                            });
                          }
                        }}
                        disabled={!isEditingPreset}
                        style={{
                          flex: 1,
                          padding: '12px',
                          borderRadius: '10px',
                          border: 'none',
                          fontSize: '16px',
                          fontWeight: 'bold',
                          cursor: !isEditingPreset ? 'not-allowed' : 'pointer',
                          background: '#FF9800',
                          color: '#FFFFFF',
                          opacity: !isEditingPreset ? 0.5 : 1
                        }}
                      >
                        Save
                      </button>
                      <button
                        onClick={() => {
                          setCustomPresetSettings(null);
                          setIsEditingPreset(false);
                          const preset = PRESETS[selectedPreset];
                          updateConfig({
                            ...gameData.config,
                            numWords: preset.numWords,
                            roundTimer: preset.roundTimer,
                            numRounds: preset.numRounds,
                            bonusWords: preset.bonusWords,
                            difficulty: preset.difficulty,
                            presetLevel: selectedPreset
                          });
                        }}
                        style={{
                          flex: 1,
                          padding: '12px',
                          borderRadius: '10px',
                          border: 'none',
                          fontSize: '16px',
                          fontWeight: 'bold',
                          cursor: 'pointer',
                          background: '#F44336',
                          color: '#FFFFFF'
                        }}
                      >
                        Reset
                      </button>
                    </div>
                    
                    {/* Let's Play Button */}
                    <button
                      onClick={startGame}
                      disabled={players.length < 1}
                      style={{
                        width: '100%',
                        padding: '18px',
                        borderRadius: '12px',
                        background: 'transparent',
                        border: '3px solid #FFFFFF',
                        color: '#FFFFFF',
                        fontSize: '24px',
                        fontWeight: 'bold',
                        cursor: players.length < 1 ? 'not-allowed' : 'pointer',
                        opacity: players.length < 1 ? 0.5 : 1,
                        transition: 'all 0.2s'
                      }}
                    >
                      {players.length < 1 ? 'WAITING FOR PLAYERS...' : "Let's Play"}
                    </button>
                  </>
                )}
                
                {/* Non-host waiting message */}
                {!isHost && (
                  <div style={{
                    background: '#FFFFFF',
                    border: '3px solid #00BCD4',
                    borderRadius: '15px',
                    padding: '20px',
                    textAlign: 'center',
                    marginTop: '20px'
                  }}>
                    <p style={{fontWeight: 'bold', color: '#00BCD4', fontSize: '18px'}}>
                      Waiting for host to start the game...
                    </p>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      }
      if (gameData?.gameState === 'playing') {
        const timeRemaining = getTimeRemaining();
        const myPlayer = players.find(p => p.id === playerId);
        const mySubmissions = myPlayer?.submissions || [];
        
        return (
          <div className="h-screen bg-gray-50 flex flex-col overflow-hidden">
            {/* Room Code - Fixed at top */}
            <div className="absolute top-4 left-4 bg-white rounded-lg shadow px-3 py-2 z-10">
              <span className="text-xs text-gray-600">{isPracticeMode ? 'Practice' : 'Room'}:</span>
              <span className="ml-1 font-mono font-bold text-blue-600">{isPracticeMode ? 'Solo' : roomCode}</span>
            </div>
            
            {/* Pause Button (Practice Mode Only) - Fixed at top center */}
            {isPracticeMode && (
              <button
                onClick={() => setIsPaused(!isPaused)}
                className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-white rounded-lg shadow px-4 py-2 z-10 text-5xl font-bold hover:bg-gray-100 transition"
                title={isPaused ? "Resume game" : "Pause game"}
              >
                {isPaused ? 'RESUME' : 'PAUSE'}
              </button>
            )}
            
            {/* Mute Button - Fixed at top right */}
            <button
              onClick={toggleSound}
              className="absolute top-4 right-4 bg-white rounded-lg shadow px-3 py-2 z-10 text-5xl hover:bg-gray-100 transition"
              title={soundMuted ? "Unmute sounds" : "Mute sounds"}
            >
              {soundMuted ? '' : ''}
            </button>
            
            {/* Scrollable content area */}
            <div className="flex-1 overflow-y-auto pt-16 pb-4 px-4">
              <div className="max-w-4xl mx-auto">
                {/* Timer */}
                <div className="text-center mb-4">
                  <div className={`inline-block ${timeRemaining < 30 ? 'bg-vermillion animate-pulse' : 'bg-vermillion'} text-white px-5 py-2 rounded-lg text-5xl font-bold`}>
                    {formatTime(timeRemaining)}
                  </div>
                </div>

                {/* Word Grid */}
                <div className="bg-white rounded-lg p-4 shadow-lg mb-4">
                  <h3 className="text-xs font-semibold mb-2 text-gray-700">Tap words to select:</h3>
                  <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
                    {(gameData.randomWords || []).map((wordObj, idx) => {
                      const wordText = typeof wordObj === 'string' ? wordObj : wordObj.text;
                      const isBonus = typeof wordObj === 'object' && wordObj.isBonus;
                      const isSelected = selectedWords.includes(wordText);
                      
                      return (
                        <div
                          key={idx}
                          onClick={() => toggleWord(wordText)}
                          className={`${
                            isSelected
                              ? 'bg-dark-cyan text-white border-dark-cyan'
                              : isBonus
                                ? 'bg-gradient-to-br from-yellow-100 to-amber-100 text-gray-900 border-amber-400 shadow-md'
                                : 'bg-white text-gray-800 border-blue-400'
                          } border-2 rounded-lg p-2 text-center font-semibold text-xs cursor-pointer hover:shadow-lg transition relative`}
                          style={isBonus && !isSelected ? {
                            boxShadow: '0 0 15px rgba(251, 191, 36, 0.4)'
                          } : {}}
                        >
                          {isBonus && !isSelected && (
                            <span className="absolute top-0 right-0 text-amber-500 text-lg"></span>
                          )}
                          {wordText}
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            </div>

            {/* Fixed input section at bottom */}
            <div className="bg-cerulean-light border-t-4 border-cerulean p-4 shadow-lg">
              <div className="max-w-4xl mx-auto">
                <div className="grid grid-cols-2 gap-3 mb-3">
                  <div>
                    <label className="block text-xs font-semibold mb-1 text-gray-700">WORDS:</label>
                    <div className="w-full p-3 border-2 border-gray-300 rounded-lg bg-white text-5xl min-h-[45px] flex items-center overflow-x-auto">
                      {selectedWords.join(' - ') || 'Select words above'}
                    </div>
                  </div>
                  <div>
                    <label className="block text-xs font-semibold mb-1 text-gray-700">LINK:</label>
                    <input
                      id="linkWordInput"
                      type="text"
                      value={linkWord}
                      onChange={(e) => {
                        setLinkWord(e.target.value);
                        
                        // Clear existing timer
                        if (spellCheckTimer) {
                          clearTimeout(spellCheckTimer);
                        }
                        
                        // Set new timer to trigger spell check after 500ms of no typing
                        const timer = setTimeout(() => {
                          const input = document.getElementById('linkWordInput');
                          if (input) {
                            input.blur();
                            setTimeout(() => input.focus(), 10);
                          }
                        }, 500);
                        
                        setSpellCheckTimer(timer);
                      }}
                      onKeyPress={(e) => e.key === 'Enter' && submitLink()}
                      autoComplete="off"
                      autoCorrect="off"
                      autoCapitalize="off"
                      spellCheck="true"
                      className="w-full p-3 border-2 border-cerulean rounded-lg text-sm"
                      placeholder="Type link word"
                    />
                  </div>
                </div>
                <button
                  onClick={submitLink}
                  disabled={selectedWords.length < 2 || !linkWord.trim()}
                  className="w-full bg-dark-cyan text-white py-3 rounded-lg font-semibold hover:bg-dark-cyan-dark transition disabled:bg-gray-300 disabled:cursor-not-allowed text-lg"
                >
                  SUBMIT ({mySubmissions.length})
                </button>
              </div>
            </div>
          </div>
        );
      }

      if (gameData?.gameState === 'roundOver') {
        const myPlayer = players.find(p => p.id === playerId);
        const youReady = myPlayer?.ready || false;
        const readyCount = players.filter(p => p.ready).length;
        const currentChallenge = getCurrentChallenge();
        const hasChallenges = (gameData.challenges || []).length > 0;
        
        // Star voting functionality
        const hasVoted = gameData.starVotes && gameData.starVotes[playerId];
        
        const handleStarVote = (votedForId, submissionIndex) => {
          if (votedForId === playerId) {
            console.log('Cannot vote for self');
            return; // Can't vote for self
          }
          if (hasVoted) {
            console.log('Already voted this round');
            return; // Already voted
          }
          
          console.log('Star vote:', playerId, 'voting for', votedForId, 'submission', submissionIndex);
          playSound('star'); // Play sparkle sound
          
          const voteData = {
            votedFor: votedForId,
            submissionIndex: submissionIndex,
            timestamp: Date.now()
          };
          
          if (isPracticeMode) {
            // Practice mode - update local state
            updatePracticeGameState({
              starVotes: {
                ...(gameData.starVotes || {}),
                [playerId]: voteData
              }
            });
            console.log('Star vote saved to local state');
          } else {
            // Multiplayer mode - update Firebase
            database.ref(`rooms/${roomCode}/starVotes/${playerId}`).set(voteData).then(() => {
              console.log('Star vote saved successfully');
            }).catch(err => {
              console.error('Error saving star vote:', err);
            });
          }
        };
        
        return (
          <div className="min-h-screen p-6" style={{background: 'linear-gradient(135deg, #0a1e3d 0%, #162d50 50%, #1e4d8b 100%)'}}>
            <div className="absolute top-4 left-4 rounded-xl shadow-lg px-4 py-3 z-10" style={{backgroundColor: '#2557a0', border: '2px solid #3d6db5'}}>
              <span className="text-xs text-white">Room:</span>
              <span className="ml-1 font-mono font-bold" style={{color: '#f5b942'}}>{roomCode}</span>
            </div>
            
            {/* Mute Button */}
            <button
              onClick={toggleSound}
              className="absolute top-4 right-4 rounded-xl shadow-lg px-4 py-3 z-10 text-5xl hover:opacity-80 transition"
              style={{backgroundColor: '#2557a0', border: '2px solid #3d6db5', color: 'white'}}
              title={soundMuted ? "Unmute sounds" : "Mute sounds"}
            >
              {soundMuted ? '' : ''}
            </button>
            
            <div className="max-w-6xl mx-auto">
              <h2 className="text-5xl font-bold text-center mb-6" style={{color: '#4ade80'}}>
                ROUND {gameData.currentRound} COMPLETE!
              </h2>
              
              {/* All Players Scoring */}
              <div className="space-y-6 mb-6">
                {players.map((player) => {
                  const isYou = player.id === playerId;
                  const roundScore = (player.submissions || []).reduce((sum, sub) => sum + (sub.accepted ? sub.points : 0), 0);
                  
                  return (
                    <div 
                      key={player.id} 
                      className="rounded-xl shadow-2xl p-6 border-4"
                      style={{
                        backgroundColor: isYou ? '#e9d5ff' : '#ddd6fe',
                        borderColor: isYou ? '#c084fc' : '#a78bfa'
                      }}
                    >
                      <div className="mb-4">
                        <div className="flex items-center justify-between mb-2">
                          <h3 className="text-5xl font-bold" style={{color: '#1e293b'}}>
                            Scoring
                          </h3>
                        </div>
                        <div className="flex items-center gap-2">
                          <label className="font-bold text-lg" style={{color: '#1e293b'}}>Players Name:</label>
                          <div className="px-4 py-2 rounded-lg" style={{backgroundColor: 'white', color: '#9ca3af', border: '2px solid #d1d5db'}}>
                            {player.name}
                          </div>
                        </div>
                      </div>
                      
                      {/* Scoring Table */}
                      <div className="rounded-xl overflow-hidden" style={{backgroundColor: 'white', border: '3px solid #a78bfa'}}>
                        {/* Table Header */}
                        <div className="grid grid-cols-12 gap-2 px-4 py-3" style={{backgroundColor: '#f3f4f6', borderBottom: '2px solid #d1d5db'}}>
                          <div className="col-span-1 font-bold text-center">#</div>
                          <div className="col-span-4 font-bold">Words</div>
                          <div className="col-span-2 font-bold text-center" style={{color: '#3b82f6'}}>Link Word</div>
                          <div className="col-span-2 font-bold text-center">Challenge</div>
                          <div className="col-span-2 font-bold text-center">Like</div>
                          <div className="col-span-1 font-bold text-right">Points</div>
                        </div>
                        
                        {/* Table Rows */}
                        {(player.submissions || []).map((sub, subIdx) => {
                          const isChallenged = isSubmissionChallenged(player.id, subIdx);
                          const isCurrent = isCurrentChallenge(player.id, subIdx);
                          
                          return (
                            <div 
                              key={subIdx} 
                              className="grid grid-cols-12 gap-2 px-4 py-3 items-center"
                              style={{
                                borderBottom: subIdx < player.submissions.length - 1 ? '1px solid #e5e7eb' : 'none',
                                backgroundColor: isCurrent ? '#fef3c7' : isChallenged ? '#fee2e2' : 'white'
                              }}
                            >
                              <div className="col-span-1 font-semibold text-center">{subIdx + 1}.</div>
                              <div className="col-span-4 font-medium text-sm">{sub.words.join(' - ')}</div>
                              <div className="col-span-2 font-bold text-center" style={{color: '#3b82f6'}}>{sub.link}</div>
                              
                              {/* Challenge Button */}
                              <div className="col-span-2 flex justify-center">
                                <button
                                  onClick={() => isChallenged ? removeChallenge(player.id, subIdx) : addChallenge(player.id, subIdx)}
                                  className="w-10 h-10 rounded-full flex items-center justify-center text-5xl font-bold transition hover:scale-110"
                                  style={{
                                    backgroundColor: isChallenged ? '#f59e0b' : '#3b82f6',
                                    color: 'white',
                                    border: '3px solid white',
                                    boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
                                    cursor: isYou ? 'not-allowed' : 'pointer',
                                    opacity: isYou ? 0.5 : 1
                                  }}
                                  title={isChallenged ? "Remove challenge" : "Challenge this submission"}
                                  disabled={isYou}
                                >
                                  {isChallenged ? '' : '?'}
                                </button>
                              </div>
                              
                              {/* Like Button */}
                              <div className="col-span-2 flex justify-center">
                                <button
                                  onClick={() => {
                                    if (!isYou && !hasVoted) {
                                      handleStarVote(player.id, subIdx);
                                    }
                                  }}
                                  className="w-10 h-10 rounded-full flex items-center justify-center text-5xl font-bold transition hover:scale-110"
                                  style={{
                                    backgroundColor: hasVoted ? '#f59e0b' : '#3b82f6',
                                    color: 'white',
                                    border: '3px solid white',
                                    boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
                                    cursor: isYou || hasVoted ? 'not-allowed' : 'pointer',
                                    opacity: isYou || hasVoted ? 0.5 : 1
                                  }}
                                  title={isYou ? "Can't vote for yourself" : hasVoted ? "Already voted" : "Vote for funniest/most creative"}
                                  disabled={isYou || hasVoted}
                                >
                                  
                                </button>
                              </div>
                              
                              <div className="col-span-1 text-right">
                                {isCurrent ? (
                                  <span className="text-xs font-bold px-2 py-1 rounded" style={{backgroundColor: '#fbbf24', color: 'white'}}>ACTIVE</span>
                                ) : isChallenged ? (
                                  <span className="text-xs font-bold px-2 py-1 rounded" style={{backgroundColor: '#f59e0b', color: 'white'}}>QUEUED</span>
                                ) : sub.accepted ? (
                                  <span className="font-bold" style={{color: '#22c55e'}}>{sub.points}pt</span>
                                ) : (
                                  <span className="font-bold line-through" style={{color: '#ef4444'}}>{sub.points}pt</span>
                                )}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                      
                      {/* Round Score */}
                      <div className="mt-4 text-right">
                        <span className="text-5xl font-bold" style={{color: '#1e293b'}}>
                          Round Score: {roundScore} pts
                        </span>
                      </div>
                    </div>
                  );
                })}
              </div>

              {/* Round Over / Game Over Button */}
              <button
                onClick={handleReady}
                disabled={youReady || hasChallenges}
                className="w-full py-5 rounded-xl font-bold text-5xl transition shadow-xl"
                style={{
                  backgroundColor: youReady || hasChallenges ? '#9ca3af' : '#3b82f6',
                  color: 'white',
                  cursor: youReady || hasChallenges ? 'not-allowed' : 'pointer'
                }}
              >
                {hasChallenges 
                  ? 'RESOLVE CHALLENGES FIRST' 
                  : youReady 
                    ? `READY (${readyCount}/${players.length})` 
                    : gameData.currentRound >= gameData.config.numRounds
                      ? 'GAME OVER'
                      : 'ROUND OVER'
                }
              </button>

              {youReady && (
                <div className="text-center mt-4" style={{color: '#e5e7eb'}}>
                  <p className="text-lg">Waiting for other players...</p>
                  <p className="text-sm">Ready: {players.filter(p => p.ready).map(p => p.name).join(', ')}</p>
                </div>
              )}
            </div>
          </div>
        );
      }

      if (gameData?.gameState === 'gameEnd') {
        // Calculate bonus points from star votes
        console.log('Star votes:', gameData.starVotes);
        const bonusPoints = {};
        players.forEach(p => bonusPoints[p.id] = 0);
        
        if (gameData.starVotes) {
          Object.values(gameData.starVotes).forEach(vote => {
            if (vote && vote.votedFor) {
              bonusPoints[vote.votedFor] = (bonusPoints[vote.votedFor] || 0) + 1;
              console.log('Vote counted for:', vote.votedFor, 'New total:', bonusPoints[vote.votedFor]);
            }
          });
        }
        
        console.log('Final bonus points:', bonusPoints);
        
        // Calculate total scores including bonus
        const playersWithBonus = players.map(p => ({
          ...p,
          bonusPoints: bonusPoints[p.id] || 0,
          totalWithBonus: p.totalScore + (bonusPoints[p.id] || 0)
        }));
        
        console.log('Players with bonus:', playersWithBonus);
        
        const sortedPlayers = [...playersWithBonus].sort((a, b) => b.totalWithBonus - a.totalWithBonus);
        const topScore = sortedPlayers[0].totalWithBonus;
        const winners = sortedPlayers.filter(p => p.totalWithBonus === topScore);
        const isTie = winners.length > 1;
        
        return (
          <div className="min-h-screen p-4 flex flex-col items-center justify-center" style={{background: 'linear-gradient(135deg, #0a1e3d 0%, #162d50 50%, #1e4d8b 100%)'}}>
            <div className="absolute top-4 left-4 rounded-xl shadow-lg px-4 py-3 z-10" style={{backgroundColor: '#2557a0', border: '2px solid #3d6db5'}}>
              <span className="text-xs text-white">Room:</span>
              <span className="ml-1 font-mono font-bold" style={{color: '#f5b942'}}>{roomCode}</span>
            </div>
            
            {/* Mute Button - Fixed at top right */}
            <button
              onClick={toggleSound}
              className="absolute top-4 right-4 bg-white rounded-lg shadow px-3 py-2 z-10 text-5xl hover:bg-gray-100 transition"
              title={soundMuted ? "Unmute sounds" : "Mute sounds"}
            >
              {soundMuted ? '' : ''}
            </button>
            
            <div className="max-w-3xl w-full">
              <div className="text-center mb-8">
                <img src="./trophy.png" alt="Trophy" style={{width: "200px", height: "auto", margin: "0 auto 30px"}} />
                {isTie ? (
                  <>
                    <h1 className="text-6xl font-bold text-gold mb-2">TIE GAME!</h1>
                    <h2 className="text-5xl font-bold text-gray-800 mb-2">
                      {winners.map(w => w.name).join(' & ')}
                    </h2>
                    <p className="text-5xl text-gray-600">{topScore} points each</p>
                  </>
                ) : (
                  <>
                    <h1 className="text-6xl font-bold text-gold mb-2">WINNER!</h1>
                    <h2 className="text-5xl font-bold text-gray-800 mb-2">{sortedPlayers[0].name}</h2>
                    <p className="text-5xl text-gray-600">{sortedPlayers[0].totalWithBonus} points</p>
                  </>
                )}
              </div>

              <div className="bg-white rounded-lg p-6 shadow-xl mb-6">
                <h3 className="font-bold text-5xl mb-4 text-center">Final Standings</h3>
                
                {/* Table Header */}
                <div className="grid grid-cols-4 gap-4 mb-3 pb-3 border-b-2 border-gray-300">
                  <div className="font-bold text-center"></div>
                  <div className="font-bold text-center">Round Points</div>
                  <div className="font-bold text-center">Bonus Points</div>
                  <div className="font-bold text-center">Total Points</div>
                </div>
                
                {/* Player Rows */}
                <div className="space-y-3">
                  {sortedPlayers.map((player, idx) => (
                    <div key={player.id} className="grid grid-cols-4 gap-4 items-center p-4 rounded-lg bg-gray-50 border border-gray-200">
                      <div className="flex items-center gap-2">
                        <span className="text-5xl font-bold text-gray-500">{idx + 1}</span>
                        <span className="font-semibold text-lg">{player.name}</span>
                      </div>
                      <div className="text-center text-5xl font-bold">{player.totalScore} pts</div>
                      <div className="text-center text-5xl font-bold text-gold">{player.bonusPoints} pts</div>
                      <div className="text-center text-5xl font-bold text-green-600">{player.totalWithBonus} pts</div>
                    </div>
                  ))}
                </div>
              </div>

              <button
                onClick={async () => {
                  // Reset game back to lobby
                  const updates = {};
                  players.forEach(p => {
                    updates[`players/${p.id}/ready`] = false;
                    updates[`players/${p.id}/submissions`] = [];
                    updates[`players/${p.id}/totalScore`] = 0;
                  });
                  
                  await database.ref(`rooms/${roomCode}`).update({
                    ...updates,
                    gameState: 'lobby',
                    currentRound: 0,
                    challenges: [],
                    currentChallengeIndex: 0,
                    randomWords: [],
                    recentlyUsedWords: [],
                    starVotes: {},
                    timer: null,
                    timerStartTime: null
                  });
                }}
                className="w-full bg-dark-cyan hover:bg-dark-cyan-dark text-white px-8 py-4 rounded-lg font-bold text-5xl transition mb-3"
              >
                PLAY AGAIN
              </button>

              {isHost && (
                <button
                  onClick={() => window.location.reload()}
                  className="w-full bg-gray-500 hover:bg-gray-600 text-white px-8 py-4 rounded-lg font-bold text-5xl transition"
                >
                  NEW GAME (NEW ROOM)
                </button>
              )}
            </div>
          </div>
        );
      }

      return null;
    };

    // Challenge view component
    const RoundOverChallengeView = ({ currentChallenge, players, playerId, submitDefense, submitVote, removeChallenge, gameData }) => {
      const [defenseInput, setDefenseInput] = useState('');
      const challengedPlayer = players.find(p => p.id === currentChallenge.playerId);
      const submission = challengedPlayer?.submissions?.[currentChallenge.subIdx];
      const isDefender = currentChallenge.defenderId === playerId;
      const hasVoted = currentChallenge.votes && currentChallenge.votes[playerId];
      const showResult = currentChallenge.result !== null && currentChallenge.result !== undefined;
      const challenges = gameData.challenges || [];
      const currentIndex = gameData.currentChallengeIndex || 0;
      
      // Debug logging
      console.log('RoundOverChallengeView render:', {
        result: currentChallenge.result,
        showResult: showResult,
        defense: currentChallenge.defense,
        votes: currentChallenge.votes,
        isDefender: isDefender,
        hasVoted: hasVoted,
        playerId: playerId,
        defenderId: currentChallenge.defenderId
      });

      const handleDefendClick = () => {
        if (defenseInput.trim()) {
          submitDefense(defenseInput);
        }
      };

      const getVoteCount = () => {
        if (!currentChallenge.votes) return { acceptCount: 0, rejectCount: 0 };
        const votes = Object.values(currentChallenge.votes);
        return {
          acceptCount: votes.filter(v => v === 'accept').length,
          rejectCount: votes.filter(v => v === 'reject').length
        };
      };

      return (
        <div className="bg-honey-yellow-light border-2 border-honey-yellow rounded-lg p-4 mb-6">
          <div className="flex justify-between items-center mb-4">
            <h3 className="font-bold text-5xl text-honey-yellow">
              Challenge {currentIndex + 1} of {challenges.length}
            </h3>
            <button 
              onClick={() => removeChallenge(currentChallenge.playerId, currentChallenge.subIdx)}
              className="text-5xl text-gray-600 underline hover:text-gray-800"
            >
              Remove Challenge
            </button>
          </div>
          
          <div className="bg-white p-4 rounded mb-4">
            <p className="font-medium mb-2 text-lg">
              <span className="text-honey-yellow">{challengedPlayer?.name}'s submission:</span>
            </p>
            <p className="text-5xl font-bold mb-1">
              {submission?.words.join(' - ')}  {submission?.link}
            </p>
            <p className="text-5xl text-gray-600">({submission?.points} points)</p>
          </div>

          {/* Show result if voting is complete */}
          {showResult && (
            <div className={`${currentChallenge.result === 'accepted' ? 'bg-dark-cyan-light border-dark-cyan' : 'bg-vermillion-light border-vermillion'} border-2 rounded-lg p-6 text-center mb-4`}>
              <div className="text-5xl mb-2">{currentChallenge.result === 'accepted' ? '' : ''}</div>
              <h3 className={`text-5xl font-bold ${currentChallenge.result === 'accepted' ? 'text-dark-cyan' : 'text-vermillion'}`}>
                {currentChallenge.result === 'accepted' ? 'ACCEPTED' : 'REJECTED'}
              </h3>
            </div>
          )}

          {/* Defense Section */}
          {!showResult && (
            <>
              {isDefender && !currentChallenge.defense ? (
                <div className="bg-cerulean-light p-4 rounded mb-4">
                  <label className="block font-semibold mb-2">Defend your link:</label>
                  <input
                    type="text"
                    value={defenseInput}
                    onChange={(e) => setDefenseInput(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && defenseInput.trim() && handleDefendClick()}
                    placeholder="Explain why this link makes sense..."
                    className="w-full p-3 border-2 border-gray-300 rounded mb-2"
                  />
                  <button
                    onClick={handleDefendClick}
                    disabled={!defenseInput.trim()}
                    className="bg-cerulean text-white px-6 py-2 rounded hover:bg-cerulean-dark disabled:bg-gray-300"
                  >
                    SUBMIT DEFENSE
                  </button>
                </div>
              ) : currentChallenge.defense ? (
                <div className="bg-cerulean-light p-4 rounded mb-4">
                  <p className="font-semibold mb-1">Defense:</p>
                  <p className="italic text-gray-700">"{currentChallenge.defense}"</p>
                </div>
              ) : (
                <div className="bg-gray-100 p-4 rounded mb-4 text-center text-gray-600">
                  Waiting for {challengedPlayer?.name} to defend...
                </div>
              )}

              {/* Voting Section */}
              {currentChallenge.defense && !isDefender && (
                <div>
                  <h4 className="font-semibold mb-2">Cast Your Vote:</h4>
                  <div className="flex gap-4 mb-3">
                    <button
                      onClick={() => submitVote('accept')}
                      disabled={hasVoted}
                      className="flex-1 bg-dark-cyan text-white py-3 rounded-lg font-semibold hover:bg-dark-cyan-dark transition disabled:bg-gray-300"
                    >
                      ACCEPT
                    </button>
                    <button
                      onClick={() => submitVote('reject')}
                      disabled={hasVoted}
                      className="flex-1 bg-vermillion text-white py-3 rounded-lg font-semibold hover:bg-vermillion-dark transition disabled:bg-gray-300"
                    >
                      REJECT
                    </button>
                  </div>
                  {hasVoted && (
                    <p className="text-center text-5xl text-gray-600">
                      Votes: {getVoteCount().acceptCount} Accept / {getVoteCount().rejectCount} Reject
                    </p>
                  )}
                </div>
              )}

              {currentChallenge.defense && isDefender && (
                <div className="bg-gray-100 p-4 rounded text-center text-gray-600">
                  Waiting for other players to vote...
                </div>
              )}
            </>
          )}
        </div>
      );
    };

    ReactDOM.render(<MultiplayerLinkLogic />, document.getElementById('root'));
  </script>
</body>
</html>
